# 2장 객체 생성과 파괴

## 생성자 대신 정적 팩토리 메소드 고려
- 정적 팩토리 메소드 장점
  - 이름을 가질 수 있음.
    - 이름으로 설명을 잘 나타낼 수 있으면 클라이언트 입장에서 코드 읽기 쉬움
  - 호출될 때 마다 객체 생성 안할 수 있음.
    - 인스턴스 미리 만들어두거나 캐싱하여 사용 가능
    - 플라이웨이트 패턴과 비슷
    - 정적 팩토리 메소드가 있으면 인스턴스 통제 클래스라고도 할 수 있다. 
      - 싱글턴
      - 인스턴스화 불가 클래(ex. java.util.Collections)
      - 불변 값 클래스
  - 반환 타입의 하위 타입 객체를 반환 가능
    - 인터페이스 기반 프레임워크 만드는 핵심 기술
  - 입력 매개변수에 따라 다른 클래스의 객체 반환 가능
  - 정적 팩터리 메소드를 작성하는 시점에는 반환할 객체의 클래스가 없어도 됨.
    - 어차피 상위의 타입으로 반환할 것이니
    - 서비스 제공자 프레임워크의(Service provider framework) 근간
      - ex) JDBC
      - 4개의 핵심 컴포넌트
        - 서비스 인터페이스: 구현체의 동작 정의
        - 제공자 등록 API: 구현체 등록에 사용
        - 서비스 접근 API: 클라이언트가 서비스의 인스턴스 접근에 사용
        - 서비스 제공자 인터페이스: 없다면 각 구현체를 인스턴스로 만들 때 리플렉션 사용 필요
          
- 정적 팩토리 메소드 단점
  - 정적 팩토리만 제공하면 하위 클래스 생성 불가
    - public, protected 생성자가 없으면 상속 불가
    - 상속해도 부모의 필드 값을 채우지 못하니깐 그런건가?(super(...) 를 호출하지 못하니)
    - 오히려 장점이 될 수 있음
      - 상속보다 컴포지션 사용하도록 유도
      - 불변 타입
  - 프로그래머가 찾기 어렵다
    - 생성자 처럼 API 설명에 명확히 드러나지 않음
    - 그래서 API 문서도 잘 쓰고 메소드 이름도 널리 알려진 규약을 따르는게 좋다.

정적 팩토리 메소드 예 (디자인 패턴의 팩토리 메소드 패턴과는 다르다)
```java
public static Boolean valueOf(boolean b) {
    return b ? Boolean.True : Boolean.False;
}
```

## 생성자에 매개변수가 많다면 빌더를 고려하라
- 빌더 외 객체 생성 방법
  - 점층적 생성자 패턴
    - 생성자를 오버로딩하여 매개변수 상황에 맞는 여러 생성자를 만드는 것. 클라이언트는 자신의 상황에 맞는 적절한 생성자 하나를 선택한다.
    - 매개변수가 많아질수록 코드 작성 및 읽기가 어려워진다. 
  - 자바빈즈 패턴
    - 빈 객체 생성 후 setter들을 호출하여 객체의 필드를 채우는 방식
    - 불변 달성이 불가능함
      - 스레드 안정성 떨어짐. 
    - 객체가 완성되기 전까지 일관성이 무너진 상태
      - 디버깅의 어려움
- 빌더 패턴은 파이썬이나 스칼라에 있는 명명된 선택적 매개변수를 흉내낸 것
- 빌더 생성 방법
  - 빌더 객체 획득
  - 빌더 생성할 클래스안에 정적 멤버 클래스로 만드는게 보통
  - 빌더 클래스는 생성할 클래스의 멤버 변수를 그대로 가짐.
  - 필수 매개변수는 빌더 클래스의 생성자로 받고, 선택 매개변수는 일종의 세터 메소드를 통해 세팅
    - 세터 메소드는 빌더 자기 자신을 반환하여 메소드 체이닝이 가능하도록 한다. 
  - 마지막으로 build 메소드를 호출하여 생성할 클래스의 객체를 만들고 반환한다.
    - 생성하고자 하는 클래스의 생성자는 빌더 객체를 파라미터로 받도록 한다. 
  - 빌더 클래스엔 유효성 검사 코드등을 추가할 수 있다. 
    - 검사에서 잘못된 부분을 찾으면 어떤 매개변수가 문제인지 자세히 알려주는 메시지를 담아 IllegalArgumentException을 던지면 된다. 

- 빌더는 계층적으로 설계된 클래스와 함께 쓰기 좋다
  - 계층적 설계 클래스 예: 피자(추상, 상위), 뉴욕피자(하위), 칼초네피자(하위)
  - 추상 클래스는 추상 빌더, 구체 클래스는 구체 빌더를 갖게 한다. 
    - 공변 반환 타이핑: 하위 클래스의 메소드가 상위 클래스의 메소드가 정의한 반환 타입이 아닌, 그 하위 타입을 반환하는 기능

- 장점
  - 점층적 생성자 패턴에 비해 클라이언트 코드를 읽고 쓰기 간편
  - 자바 빈즈보다 훨씬 안전
- 단점
  - 굳이 따지면, 빌더 객체 생성이 필요. 그 비용이 크진 않지만 성능에 민감한 상황에서 문제가 될 수 있음.
  - 점층적 생성자 패턴에 비해 코드가 장황해져서(클라이언트 부분이 아닌) 매개변수가 4개 이상 되어야 값어치 한다? -> 이것도 롬복의 빌더 쓰면 문제가 없을듯.

## private 생성자나 열거 타입으로 싱글턴임을 보증하라
- 클래스를 싱글턴으로 만들면 이를 사용하는 클라이언트를 테스트하기 어려워질 수 있다.
  - 싱글턴 인스턴스를 mock 구현으로 대체할 수 없기 때문
- 싱글턴을 만드는 방법
  - private 생성자
    - 생성자의 접근제어자를 private로 하고, static final 멤버변수에 싱글턴 객체를 할당하는 방식
    - 싱글턴 제공 방법
      - static final 멤버 변수의 접근제어자를 Public으로 하는 방법
        - 해당 클래스가 싱글턴임이 API에 명백히 드러나는 장점
      - public 정적 팩토리 메소드로 제공하는 방법 
        - 장점
          - API를 바꾸지 않고도, 싱글턴이 아니게 변경할 수 있음
          - 정적 팩토리를 제네릭 싱글턴 팩토리로 변경 가능
          - 정적 팩토리의 메서드 참조를 공급자(supplier)로 사용할 수 있음
    - private 생성자 방식으로 싱글턴 만들 경우 역직렬화할 때 마다 새로운 인스턴스가 생성 된다.
      - Serializable 구현
      - 모든 필드를 transient라고 선언
      - readResolve 메소드 제공 필요
  - 열거 타입 방식
    - 대부분의 상황에선 열거타입 방식이 가장 좋다
      - 장점
        - 간결
        - 추가 노력 없이 직렬화 가능
        - 복잡한 직렬화 상황이나 리플렉션 공격에도 제 2의 인스턴스가 생기는 일을 완벽히 막아줌
      - 단점
        - 만드려고하는 싱글턴이 enum외 클래스를 상속해야 한다면 사용 불가
    - ```java
      public enum Elvis {
        INSTANCE;
        public void leaveTheBuilding() {...}
      }
      ```
      
## 인스턴스화를 막으려거든 private 생성자를 사용하라
- 정적 멤버만을 담은 클래스는 인스턴스로 만들어 쓰려고 설계한게 아니다.
- 생성자에 private를 명시하면 인스턴스화를 막을 수 있다.
  - 추상클래스로 만드는 것으론 인스턴스화 막을 수 없다
    - 하위 클래스를 만들어서 인스턴스화 하면 되기 때문

## 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라
- 사용하는 자원에 따라 동작이 달라지는 클래스엔 정적 유틸리티나(static field, static method만 있는 클래스 말하는 듯) 싱글턴 방식이 적합하지 않다.
  - 자원을 교체하는 경우, (에를들어 사전이라는 클래스의 의존을 가져서 해당 객체를 필드에 저장하고 있는 상황) 필드의 값을 변경해줘야 하는데 (일반 사전 외에 테스트용 사전, 특수 어휘용 사전 등이 있을 수 있다.), 필드를 변경하는 메소드를 추가하는 방식으론 어색하고 오류 내기 쉬우며, 멀티 스레드 환경에서 사용할 수 없다.
- 이런 클래스엔 의존 객체 주입 패턴이 적절하다
- 의존 객체 주입
  - 인스턴스를 생성할 때 생성자에 필요한 자원을 넣어주는 방식
  - ```java
    public class SpellChecker {
        private final Lexicon dictionary;
        public SpellChecker(Lexicon dictionary){
            this.dictionary = Objects.requireNonNull(dictionary);
        }
        public boolean isValid(String word) { ... }
    }
    ```
- 의존 객체 주입은 클래스의 유연성, 재사용성, 테스트 용이성을 기막히게 개선해준다. 
- 의존성이 수천개나 되면 코드가 복잡해지기는 마찬가지. 스프링, 대거, 주스 같은 객체 주입 프레임워크를 사용하면 이런 문제를 좀 더 해소 가능

## 불필요한 객체 생성을 피하라
- 기존 객체를 재사용해야 한다면 새로운 객체를 만들지 마라
- ex) 예제의 경우 String s = "abc" 라고만 할 경우 abc라는 문자열을 사용하는 모든 코드가 같은 객체를 사용할텐데 굳이 매번 새로운 객체를 만들고 있다.
  - ```java
    String s = new String("abc")
    ```
  - 박싱된 기본 타입보다는 기본 타입을 사용하고, 의도치 않은 오토박싱이 숨어들지 않도록 주의
    - 박싱된 기본 타입 ex) Long
    - 기본(Primitive) 타입 ex) long
  
## 다 쓴 객체 참조를 해제하라
- 다쓴 객체는 자바에서 가비지 컬렉터가 회수해 간다.
- 하지만 스택 컬렉션과 같이 자기 메모리를 직접 관리하는 클래스는 메모리 누수에 취약하다
  - 스택의 경우 더 이상 사용하지 않는 객체에 대해, 배열에 할당된 참조를 null로 변경해줘야 한다.
- 다 쓴 참조를 해제하는 가장 좋은 방법은 scope 밖으로 밀어내는 것
  - null 처리하는 경우는 예외적인 경우에만 사용해야 한다.
- 캐시, 리스너, 콜백 역시 메모리 누수 주범

## finalizer와 cleaner 사용을 피하라
- finalizer와 cleaner는 자바의 객체 소멸자
- Java9에서 finalizer는 deprecated되고 대안으로 cleaner를 소개
- 둘 다 일반적으로 불필요. 예측이 어렵고 느리다.
- 이 둘은 제때 수행된다는 보장이 없어, 제때 실행되어야 하는 작업에 사용 불가
- 그나마 안전망 역할이나 중요하지 않은 네이티브 자원 회수용으로 사용 가능(이마저도 불확실하고 성능 저하에 주의해야 한다.)