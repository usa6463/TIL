# 2장 객체 생성과 파괴

## 생성자 대신 정적 팩토리 메소드 고려
- 정적 팩토리 메소드 장점
  - 이름을 가질 수 있음.
    - 이름으로 설명을 잘 나타낼 수 있으면 클라이언트 입장에서 코드 읽기 쉬움
  - 호출될 때 마다 객체 생성 안할 수 있음.
    - 인스턴스 미리 만들어두거나 캐싱하여 사용 가능
    - 플라이웨이트 패턴과 비슷
    - 정적 팩토리 메소드가 있으면 인스턴스 통제 클래스라고도 할 수 있다. 
      - 싱글턴
      - 인스턴스화 불가 클래(ex. java.util.Collections)
      - 불변 값 클래스
  - 반환 타입의 하위 타입 객체를 반환 가능
    - 인터페이스 기반 프레임워크 만드는 핵심 기술
  - 입력 매개변수에 따라 다른 클래스의 객체 반환 가능
  - 정적 팩터리 메소드를 작성하는 시점에는 반환할 객체의 클래스가 없어도 됨.
    - 어차피 상위의 타입으로 반환할 것이니
    - 서비스 제공자 프레임워크의(Service provider framework) 근간
      - ex) JDBC
      - 4개의 핵심 컴포넌트
        - 서비스 인터페이스: 구현체의 동작 정의
        - 제공자 등록 API: 구현체 등록에 사용
        - 서비스 접근 API: 클라이언트가 서비스의 인스턴스 접근에 사용
        - 서비스 제공자 인터페이스: 없다면 각 구현체를 인스턴스로 만들 때 리플렉션 사용 필요
          
- 정적 팩토리 메소드 단점
  - 정적 팩토리만 제공하면 하위 클래스 생성 불가
    - public, protected 생성자가 없으면 상속 불가
    - 상속해도 부모의 필드 값을 채우지 못하니깐 그런건가?(super(...) 를 호출하지 못하니)
    - 오히려 장점이 될 수 있음
      - 상속보다 컴포지션 사용하도록 유도
      - 불변 타입
  - 프로그래머가 찾기 어렵다
    - 생성자 처럼 API 설명에 명확히 드러나지 않음
    - 그래서 API 문서도 잘 쓰고 메소드 이름도 널리 알려진 규약을 따르는게 좋다.

정적 팩토리 메소드 예 (디자인 패턴의 팩토리 메소드 패턴과는 다르다)
```java
public static Boolean valueOf(boolean b) {
    return b ? Boolean.True : Boolean.False;
}
```

## 생성자에 매개변수가 많다면 빌더를 고려하라
- 빌더 외 객체 생성 방법
  - 점층적 생성자 패턴
    - 생성자를 오버로딩하여 매개변수 상황에 맞는 여러 생성자를 만드는 것. 클라이언트는 자신의 상황에 맞는 적절한 생성자 하나를 선택한다.
    - 매개변수가 많아질수록 코드 작성 및 읽기가 어려워진다. 
  - 자바빈즈 패턴
    - 빈 객체 생성 후 setter들을 호출하여 객체의 필드를 채우는 방식
    - 불변 달성이 불가능함
      - 스레드 안정성 떨어짐. 
    - 객체가 완성되기 전까지 일관성이 무너진 상태
      - 디버깅의 어려움
- 빌더 패턴은 파이썬이나 스칼라에 있는 명명된 선택적 매개변수를 흉내낸 것
- 빌더 생성 방법
  - 빌더 객체 획득
  - 빌더 생성할 클래스안에 정적 멤버 클래스로 만드는게 보통
  - 빌더 클래스는 생성할 클래스의 멤버 변수를 그대로 가짐.
  - 필수 매개변수는 빌더 클래스의 생성자로 받고, 선택 매개변수는 일종의 세터 메소드를 통해 세팅
    - 세터 메소드는 빌더 자기 자신을 반환하여 메소드 체이닝이 가능하도록 한다. 
  - 마지막으로 build 메소드를 호출하여 생성할 클래스의 객체를 만들고 반환한다.
    - 생성하고자 하는 클래스의 생성자는 빌더 객체를 파라미터로 받도록 한다. 
  - 빌더 클래스엔 유효성 검사 코드등을 추가할 수 있다. 
    - 검사에서 잘못된 부분을 찾으면 어떤 매개변수가 문제인지 자세히 알려주는 메시지를 담아 IllegalArgumentException을 던지면 된다. 

- 빌더는 계층적으로 설계된 클래스와 함께 쓰기 좋다
  - 계층적 설계 클래스 예: 피자(추상, 상위), 뉴욕피자(하위), 칼초네피자(하위)
  - 추상 클래스는 추상 빌더, 구체 클래스는 구체 빌더를 갖게 한다. 
    - 공변 반환 타이핑: 하위 클래스의 메소드가 상위 클래스의 메소드가 정의한 반환 타입이 아닌, 그 하위 타입을 반환하는 기능

- 장점
  - 점층적 생성자 패턴에 비해 클라이언트 코드를 읽고 쓰기 간편
  - 자바 빈즈보다 훨씬 안전
- 단점
  - 굳이 따지면, 빌더 객체 생성이 필요. 그 비용이 크진 않지만 성능에 민감한 상황에서 문제가 될 수 있음.
  - 점층적 생성자 패턴에 비해 코드가 장황해져서(클라이언트 부분이 아닌) 매개변수가 4개 이상 되어야 값어치 한다? -> 이것도 롬복의 빌더 쓰면 문제가 없을듯.

## private 생성자나 열거 타입으로 싱글턴임을 보증하라
- 클래스를 싱글턴으로 만들면 이를 사용하는 클라이언트를 테스트하기 어려워질 수 있다.
  - 싱글턴 인스턴스를 mock 구현으로 대체할 수 없기 때문
- 싱글턴을 만드는 방법
  - private 생성자
    - 생성자의 접근제어자를 private로 하고, static final 멤버변수에 싱글턴 객체를 할당하는 방식
    - 싱글턴 제공 방법
      - static final 멤버 변수의 접근제어자를 Public으로 하는 방법
        - 해당 클래스가 싱글턴임이 API에 명백히 드러나는 장점
      - public 정적 팩토리 메소드로 제공하는 방법 
        - 장점
          - API를 바꾸지 않고도, 싱글턴이 아니게 변경할 수 있음
          - 정적 팩토리를 제네릭 싱글턴 팩토리로 변경 가능
          - 정적 팩토리의 메서드 참조를 공급자(supplier)로 사용할 수 있음
    - private 생성자 방식으로 싱글턴 만들 경우 역직렬화할 때 마다 새로운 인스턴스가 생성 된다.
      - Serializable 구현
      - 모든 필드를 transient라고 선언
      - readResolve 메소드 제공 필요
  - 열거 타입 방식
    - 대부분의 상황에선 열거타입 방식이 가장 좋다
      - 장점
        - 간결
        - 추가 노력 없이 직렬화 가능
        - 복잡한 직렬화 상황이나 리플렉션 공격에도 제 2의 인스턴스가 생기는 일을 완벽히 막아줌
      - 단점
        - 만드려고하는 싱글턴이 enum외 클래스를 상속해야 한다면 사용 불가
    - ```java
      public enum Elvis {
        INSTANCE;
        public void leaveTheBuilding() {...}
      }
      ```