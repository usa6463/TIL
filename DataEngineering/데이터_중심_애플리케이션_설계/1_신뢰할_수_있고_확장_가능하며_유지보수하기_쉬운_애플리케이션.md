# 신뢰할수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션

## data-intensive
- 오늘날 많은 애플리케이션이 compute-intensive가 아니라 data-intensive하다. 
- CPU 성능은 app의 제한 요소가 아니며 보통 데이터의 양, 데이터의 복잡도, 데이터의 변화 속도가 더 큰 문제
- standard building block(표준 구성 요소)를 통해 만든다
    - 데이터베이스: 나중에 데이터를 찾을 수 있게 저장할 수 있는 곳
    - 캐시: 읽기 속도 향상을 위해 값 비싼 수행 결과 기억
    - 검색 색인(search index): 키워드로 데이터 검색하거나 다양한 필터링 방법 제공
    - 스트림 처리(stream processing): 비동기 처리를 위해 다른 프로세스로 메시지 보내기 위함
    - 일괄 처리(batch processing): 주기적으로 대량의 누적된 데이터 분석

## 데이터 시스템에 대한 생각
- 표준 구성 요소들을 데이터 시스템이라는 포괄적 용어로 묶는 이유?
  - 새로운 도구들은 use case별 최적화 되어서 전통적인 분류에 딱 맞지 않는다.
    - 데이터 저장과 처리를 위한 여러 새로운 도구들은 최근에 만들어짐
  - 점점 더 많은 app들이 단일 도구로는 더 이상 데이터 처리와 저장 모두 만족시킬 수 없는 광범위한 요구사항을 가짐
    - 작업은 단일 도구에서 효율적으로 수행할 수 있는 task로 나눈다
    - 다양한 도구들은 app에서 코드를 이용해 서로 연결한다.
  
## 대부분의 소프트웨어 시스템에서 중요하게 여기는 세 가지 관심사 요약
- 신뢰성(Reliability)
  - 하드웨어나 소프트웨어 결함, human error 같은 역경에 직면해도 시스템은 지속적으로 올바르게 동작해야 한다.
    - 올바르게: 원하는 성능 수준에서 정확한 기능을 수행
- 확장성(Scalability)
  - 데이터 양, 트래픽 양, 복잡도가 증가할 때 이를 처리할 수 있는 적절한 방법이 있어야 한다.
  
- 유지보수성(Maintainability)
  - 모든 사용자가 시스템 상에서 생산적으로 작업할 수 있게 해야 한다.
    - 시간이 지남에 따라 여러 다양한 사람들이 시스템 상에서 작업할 것이기 때문
  
## 신뢰성
- 소프트웨어에 대한 일반적인 기대치
  - 사용자가 기대한 기능을 수행
  - 사용자가 범한 실수나 예상치 못한 소프트웨어 사용법을 허용
  - 예상된 부하와 데이터 양에서 필수적인 사용사례를 충분히 만족
  - 허가되지 않은 접근과 오남용 방지
- 정리: 무언가 잘못되더라도 지속적으로 올바르게 동작함.
- 결함(fault): 잘못될 수 있는 일.
  - 결함을 예측하고 대처할 수 있는 시스템이 가지는 것
    - 내결함성(fault-tolerant)
    - 탄력성(resilient)
  - 특정 유형의 결함 내성에 대해서만 이야기 하는 것이 타당
    - 완벽한 내결함성은 실현 불가. 예를 들어 블랙홀이 모든 서버를 삼키면 웹 호스팅 불가
  - 결함 vs 장애
    - 결함: 사양에서 벗어난 시스템의 한 구성 요소
    - 장애: 사용자에게 필요한 서비스를 제공하지 못하고 시스템 전체가 멈춘 경우
  - 카오스 몽키(Chaos Monkey)
    - 경고 없이 개별 프로세스를 죽이는 것 같이, 고의적으로 결함을 일으켜 내결함성 시스템을 훈련하고 테스트 하는 방법
  - 보안 문제는 내결함성보다 결함 예방이 중요
  - 종류
    - 하드웨어 결함
      - HDD의 평균 장애시간(MTTF: 가동시간/장애 횟수)은 약 10~50년.
      - 1만개 디스크로 구성된 저장 클러스터는 평균적으로 하루에 한 개의 디스크가 죽는다고 예상 가능
      - 대응
        - 각 하드웨어 구성 요소에 중복(redundancy)을 추가
          - 예
            - 디스크: RAID
            - 서버: 이중 전원 디바이스, 핫 스왑 가능한 CPU
          - 부가 장점
            - 장비를 재부팅 해야하는 경우 순회식 업그레이드로 중단시간이 필요하지 않음. 
          - 필요성 증가
            - 데이터 양과 앱 계산 요구가 늘면서 더 많은 수의 장비를 사용하게 되었고, 이와 비례해 하드웨어 결함율도 증가
            - AWS 같은 클라우드 플랫폼은 가상 장비 인스턴스가 단일 장비 신뢰성 보다 유연성과 탄력성을 우선하도록 되어 있어 별도 경고 없이 사용할 수 없게 되는 상황이 일반적임
    - 소프트웨어 오류
      - 하드웨어 결함은 무작위적이고 서로 독립적으로 생각됨
        - 예를 들어, 한 장비의 디스크에 장애가 있다고 해서 다른 장비 디스크에 장애가 발생하지 않는다.
      - 시스템 내 체계적 오류(systematic error)
        - 하드웨어 결함 때 보다 예상하기 어렵다
        - 노드 간 상관관계 때문에 상관관계가 없는 하드웨어 결함보다 오히려 시스템 오류를 더욱 유발하는 경향 가짐.
        - 특정 상황에 의해 발생하기 전 까지 오랫동안 나타나지 않는다.
        - 예시
          - CPU 시간, 메모리, 디스크 공간 등 공유자원을 과도하게 사용하는 일부 프로세스
          - 잘못된 특정 입력이 있을 때 모든 애플리케이션 서버 인스턴스가 죽는 소프트웨어 버그(ex. 리눅스 커널버그)
          - 시스템의 속도가 느려져 반응이 없거나 잘못된 응답을 반환하는 서비스
          - 연쇄 장애. 한 구성 요소의 작은 결함이 다른 구성요소의 결함을 야기
        - 이 건은 신속한 해결책이 없다.
        - 아래 방법들이 문제 해결에 도움이 될 수 있다.
          - 시스템의 가정과 상호작용에 대해 주의 깊게 생각하기
          - 빈틈없는 테스트
          - 프로세스 격리(process isolation)
          - 죽은 프로세스의 재시작 허용
          - 프로덕션 환경에서 시스템 동작의 측정
          - 모니터링
          - 분석하기
    - 인적 오류
      - 인적오류에 대해 어떻게 시스템을 신뢰성 있게 만들 수 있나?
        - 오류의 가능성을 최소화 하는 방법으로 시스템 설계(ex. 잘 설계된 추상화, API 등)
          - 인터페이스가 너무 제한적이면 사람들은 해당 인터페이스를 피해 작업하게 됨. 균형을 맞춰야함
        - 인적 오류가 발생할 수 있는 부분을 분리하라 (샌드박스 제공)
        - 철저한 테스트
          - 단위 테스트부터 전체 시스템 통합 테스트, 수동 테스트 까지
        - 인적 오류에 대한 빠르고 쉬운 복구
          - 빠른 롤백
          - 새로운 코드를 서서히 롤 아웃
          - 데이터 재계산 도구 제공
        - 모니터링 대책
        - 조작 교육과 실습 시행
- 신뢰성의 중요도
  - 원자력 발전소, 항공 교통 관제 소프트웨어만을 위한게 아니라 일상적인 애플리케이션도 안정적으로 작동해야 한다. 
  - 신뢰성을 희생해야하는 상황 예
    - 증명되지 않은 시장을 위해 시제품 개발하는 경우
    - 매우 작은 이익률의 서비스를 운영하는 경우
  
  

    