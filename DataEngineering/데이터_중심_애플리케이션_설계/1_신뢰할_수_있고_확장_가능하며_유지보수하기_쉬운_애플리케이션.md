# 신뢰할수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션

## data-intensive
- 오늘날 많은 애플리케이션이 compute-intensive가 아니라 data-intensive하다. 
- CPU 성능은 app의 제한 요소가 아니며 보통 데이터의 양, 데이터의 복잡도, 데이터의 변화 속도가 더 큰 문제
- standard building block(표준 구성 요소)를 통해 만든다
    - 데이터베이스: 나중에 데이터를 찾을 수 있게 저장할 수 있는 곳
    - 캐시: 읽기 속도 향상을 위해 값 비싼 수행 결과 기억
    - 검색 색인(search index): 키워드로 데이터 검색하거나 다양한 필터링 방법 제공
    - 스트림 처리(stream processing): 비동기 처리를 위해 다른 프로세스로 메시지 보내기 위함
    - 일괄 처리(batch processing): 주기적으로 대량의 누적된 데이터 분석

## 데이터 시스템에 대한 생각
- 표준 구성 요소들을 데이터 시스템이라는 포괄적 용어로 묶는 이유?
  - 새로운 도구들은 use case별 최적화 되어서 전통적인 분류에 딱 맞지 않는다.
    - 데이터 저장과 처리를 위한 여러 새로운 도구들은 최근에 만들어짐
  - 점점 더 많은 app들이 단일 도구로는 더 이상 데이터 처리와 저장 모두 만족시킬 수 없는 광범위한 요구사항을 가짐
    - 작업은 단일 도구에서 효율적으로 수행할 수 있는 task로 나눈다
    - 다양한 도구들은 app에서 코드를 이용해 서로 연결한다.
  
## 대부분의 소프트웨어 시스템에서 중요하게 여기는 세 가지 관심사 요약
- 신뢰성(Reliability)
  - 하드웨어나 소프트웨어 결함, human error 같은 역경에 직면해도 시스템은 지속적으로 올바르게 동작해야 한다.
    - 올바르게: 원하는 성능 수준에서 정확한 기능을 수행
- 확장성(Scalability)
  - 데이터 양, 트래픽 양, 복잡도가 증가할 때 이를 처리할 수 있는 적절한 방법이 있어야 한다.
  
- 유지보수성(Maintainability)
  - 모든 사용자가 시스템 상에서 생산적으로 작업할 수 있게 해야 한다.
    - 시간이 지남에 따라 여러 다양한 사람들이 시스템 상에서 작업할 것이기 때문
  
## 신뢰성
- 소프트웨어에 대한 일반적인 기대치
  - 사용자가 기대한 기능을 수행
  - 사용자가 범한 실수나 예상치 못한 소프트웨어 사용법을 허용
  - 예상된 부하와 데이터 양에서 필수적인 사용사례를 충분히 만족
  - 허가되지 않은 접근과 오남용 방지
- 정리: 무언가 잘못되더라도 지속적으로 올바르게 동작함.
- 결함(fault): 잘못될 수 있는 일.
  - 결함을 예측하고 대처할 수 있는 시스템이 가지는 것
    - 내결함성(fault-tolerant)
    - 탄력성(resilient)
  - 특정 유형의 결함 내성에 대해서만 이야기 하는 것이 타당
    - 완벽한 내결함성은 실현 불가. 예를 들어 블랙홀이 모든 서버를 삼키면 웹 호스팅 불가
  - 결함 vs 장애
    - 결함: 사양에서 벗어난 시스템의 한 구성 요소
    - 장애: 사용자에게 필요한 서비스를 제공하지 못하고 시스템 전체가 멈춘 경우
  - 카오스 몽키(Chaos Monkey)
    - 경고 없이 개별 프로세스를 죽이는 것 같이, 고의적으로 결함을 일으켜 내결함성 시스템을 훈련하고 테스트 하는 방법
  - 보안 문제는 내결함성보다 결함 예방이 중요
  - 종류
    - 하드웨어 결함
      - HDD의 평균 장애시간(MTTF: 가동시간/장애 횟수)은 약 10~50년.
      - 1만개 디스크로 구성된 저장 클러스터는 평균적으로 하루에 한 개의 디스크가 죽는다고 예상 가능
      - 대응
        - 각 하드웨어 구성 요소에 중복(redundancy)을 추가
          - 예
            - 디스크: RAID
            - 서버: 이중 전원 디바이스, 핫 스왑 가능한 CPU
          - 부가 장점
            - 장비를 재부팅 해야하는 경우 순회식 업그레이드로 중단시간이 필요하지 않음. 
          - 필요성 증가
            - 데이터 양과 앱 계산 요구가 늘면서 더 많은 수의 장비를 사용하게 되었고, 이와 비례해 하드웨어 결함율도 증가
            - AWS 같은 클라우드 플랫폼은 가상 장비 인스턴스가 단일 장비 신뢰성 보다 유연성과 탄력성을 우선하도록 되어 있어 별도 경고 없이 사용할 수 없게 되는 상황이 일반적임
    - 소프트웨어 오류
      - 하드웨어 결함은 무작위적이고 서로 독립적으로 생각됨
        - 예를 들어, 한 장비의 디스크에 장애가 있다고 해서 다른 장비 디스크에 장애가 발생하지 않는다.
      - 시스템 내 체계적 오류(systematic error)
        - 하드웨어 결함 때 보다 예상하기 어렵다
        - 노드 간 상관관계 때문에 상관관계가 없는 하드웨어 결함보다 오히려 시스템 오류를 더욱 유발하는 경향 가짐.
        - 특정 상황에 의해 발생하기 전 까지 오랫동안 나타나지 않는다.
        - 예시
          - CPU 시간, 메모리, 디스크 공간 등 공유자원을 과도하게 사용하는 일부 프로세스
          - 잘못된 특정 입력이 있을 때 모든 애플리케이션 서버 인스턴스가 죽는 소프트웨어 버그(ex. 리눅스 커널버그)
          - 시스템의 속도가 느려져 반응이 없거나 잘못된 응답을 반환하는 서비스
          - 연쇄 장애. 한 구성 요소의 작은 결함이 다른 구성요소의 결함을 야기
        - 이 건은 신속한 해결책이 없다.
        - 아래 방법들이 문제 해결에 도움이 될 수 있다.
          - 시스템의 가정과 상호작용에 대해 주의 깊게 생각하기
          - 빈틈없는 테스트
          - 프로세스 격리(process isolation)
          - 죽은 프로세스의 재시작 허용
          - 프로덕션 환경에서 시스템 동작의 측정
          - 모니터링
          - 분석하기
    - 인적 오류
      - 인적오류에 대해 어떻게 시스템을 신뢰성 있게 만들 수 있나?
        - 오류의 가능성을 최소화 하는 방법으로 시스템 설계(ex. 잘 설계된 추상화, API 등)
          - 인터페이스가 너무 제한적이면 사람들은 해당 인터페이스를 피해 작업하게 됨. 균형을 맞춰야함
        - 인적 오류가 발생할 수 있는 부분을 분리하라 (샌드박스 제공)
        - 철저한 테스트
          - 단위 테스트부터 전체 시스템 통합 테스트, 수동 테스트 까지
        - 인적 오류에 대한 빠르고 쉬운 복구
          - 빠른 롤백
          - 새로운 코드를 서서히 롤 아웃
          - 데이터 재계산 도구 제공
        - 모니터링 대책
        - 조작 교육과 실습 시행
- 신뢰성의 중요도
  - 원자력 발전소, 항공 교통 관제 소프트웨어만을 위한게 아니라 일상적인 애플리케이션도 안정적으로 작동해야 한다. 
  - 신뢰성을 희생해야하는 상황 예
    - 증명되지 않은 시장을 위해 시제품 개발하는 경우
    - 매우 작은 이익률의 서비스를 운영하는 경우

## 확장성
- 성능 저하를 유발하는 흔한 이유 중 하나는 부하 증가
- 증가한 부하에 대처하는 시스템 능력을 설명하는데 사용하는 용어
- 확장성을 논한다는 것은 "시스템이 특정 방식으로 커지면 이에 대처하기 위한 선택은 무엇인가?", "추가 부하를 다루기 위해 계산 자원을 어떻게 투입할까" 같은 질문을 고려하는 것.
- 부하 기술하기
  - 현재 부하를 간결하게 기술할 수 있어야 부하 성장 질문(부하가 두배로 되면 어떻게 될까?)을 논의할 수 있다.
  - 부하는 부하 매개변수(load parameter)라는 몇 개의 숫자로 나타낼 수 있다.
    - 예시
      - 웹 서버의 초당 요청 수
      - DB의 읽기 대 쓰기 비율
      - 대화방 동시 활성 사용자
      - 캐시 적중률
- 성능 기술하기
  - 부하가 증가할 때 어떤 일이 일어나는지 조사
    - 부하 매개변수 증가시키고 시스템 자원 변경하지 않고 유지하면 시스템 성능은 어떻게 영향 받는가?
    - 부하 매개변수 증가시킬 때 성능이 변하지 않고 유지되길 원한다면 자원을 얼마나 많이 늘려야 하나?
  - 시스템 성능
    - 일괄 처리 시스템: 처리량(throughput)
    - 온라인 시스템: 응답 시간(response time)
      - 지연시간 vs 응답시간
        - 지연시간: 요청 관점에서 처리되길 기다리는 시간
        - 응답시간: 클라이언트 관점에서 본 시간. 네트워크 지연, 큐 지연 포함
  - 기술 방법
    - 분포: 매 요청마다 응답 시간은 다르다. 단일 숫자가 아니라 분포로 생각해야 한다.
    - 특이 값(outlier): 백그라운드 프로세스의 컨텍스트 스위치, 네트워크 패킷 손실과 TCP 재전송 등으로 발생 가능
    - 백분위
      - 산술평균으론 얼마나 많은 사용자가 실제로 지연을 경험했는지 알려주지 않는다.
      - 중앙값(p50): 사용자가 보통 얼마나 오랫동안 기다려야 하는지 알고 싶다면 사용하기 좋은 지표
      - 꼬리지연시간(tail latency)
        - 상위 백분위 응답시간을 의미. 
        - 예를들어, 아마존은 99.9 분위로 내부 서비스 응답시간 요구사항을 기술한다.
      - 서비스 수준 목표(SLO), 서비스 수준 협약서(SLA)
        - 백분위는 SLO, SLA 기술에 자주 사용되고 기대 성능과 서비스 가용성을 정의하는 계약서에서도 자주 등장
        - ex
          - 응답시간 중앙값이 200밀리초 미만, 99분위가 1초 미만인 경우 정상서비스 상태 간주
          - 서비스 제공시간은 99.9% 이상이어야 한다.
  - 선두 차단(head-of-line blocking)
    - 큐 대기 지연은 높은 백분위에서 응답 시간의 상당 부분을 차지
    - 서버 CPU 코어수 제한이 있어, 소수의 느린 요청 처리가 후속 요청 처리를 지체시킬 수 있다.
    - 테스트를 위해 부하 생성하는 클라이언트는 응답 시간과 독립적으로 요청을 지속적으로 보내야 함. 
  - 실전 백분위
    - 꼬리 지연 증폭
      - 사용자 요청이 여러 백엔드 서비스에서 호출되는 경우, 병렬적이더라도 호출 중 가장 느린 호출이 완료되길 기다려야함.
    - 모니터링 대시보드에서 롤링 윈도 백분위 계산 추가
    - 백분위 근사치 계산 알고리즘들 활용(포워드 디케이, T 다이제스트 등)
- 부하 대응 접근 방식
  - 부하 수준 1단계에 적합한 아키텍처로는 10배의 부하를 대응할 수 없다. 급성장하는 서비스라면 부하 규모의 자릿수가 바뀔때마다, 혹은 그보다 자주 아키텍처 재검토 필요
  - 확장 방법
    - 용량확장(scaling up), 수직확장(vertical scaling)
      - 좀 더 강력한 장비로 이동
    - 규모확장(scaling out), 수평확장(horizontal scaling)
      - 다수의 낮은 사양 장비로 부하를 분산 
    - 실용적인 접근 방식 필요: 적절한 사양의 장비 몇대가, 대량의 낮은 사양 장비보다 훨씬 간단하고 저렴하다.
  - 탄력적(elastic)
    - 부하 증가를 감지하면 컴퓨팅 자원을 자동으로 추가할 수 있다. 
    - 탄력적인 시스템은 부하를 예측할 수 없을 만큼 높은 경우 유용하지만, 수동으로 확장하는 시스템이 더 간단하고 운영상 예상치 못한 일이 더 적다.
  - stateful 시스템 분산 설치
    - stateless 서비스를 분산 배포하는 일은 간단
    - stateful 데이터 시스템을 분산 설치하는 일은 복잡도가 추가 발생
    - 단일 노드에 DB(scale up) 유지 하다가 고가용성 요구가 생기면 분산 배포하는 통념 있음
    - 분산 시스템을 위한 도구와 추상화가 좋아지면서 일부 app에 대해 위 통념이 바뀌고 있음.
    - 대용량 데이터, 트래픽을 다루지 않더라도 분산 데이터 시스템이 향후 기본 아키텍처로 자리 잡을 가능성 있음.
  - 애플리케이션 특화
    - 대규모로 동작하는 시스템의 아키텍처는 해당 시스템을 사용하는 app에 특화
        - 초당 10만건의 1kB 요청 처리 시스템과 각 크기가 2GB인 분당 3건 요청 처리 시스템은 처리량이 같아도 아키텍처가 매우 다름.
        - 특정 app에 적합한 확장성을 갖춘 아키텍처는 주요 동작이 무엇이고, 잘 하지 않는 동작은 무엇인지에 대한 가정으로 구축
          - 이 가정은 부하 매개변수가 된다.
          - 가정이 잘못되면 확장에 대한 노력은 헛수고가 되고, 역효과가 될 수도 있다
          - 스타트업 초기 단계나 검증되지 않은 제품의 경우, 미래 부하에 대비해 확장하기 보다 빠르게 반복해서 제품 기능을 개선하는게 중요
    - 범용적이고 모든 상황에 맞는(one-size-fits-all) 확장 아키텍처는 없다.
      - 각 상황에 맞는 익숙한 아키텍처 패턴은 있다. 
    - 아키텍처를 결정하는 요소
      - 읽기, 쓰기 양
      - 저장할 데이터 양
      - 데이터 복잡도
      - 응답 시간 요구 사항
      - 접근 패턴
      - 그 외 더 많은 문제
  
## 유지보수성
- 소프트웨어 비용의 대부분은 초기 개발이 아니라 유지보수에 들어간다
  - 유지 보수 종류
    - 버그 수정
    - 시스템 운영 유지
    - 장애 조사
    - 새로운 플랫폼 적응
    - 새 사용 사례를 위한 변경
    - 기술 채무 상환
  
- 유지보수 중 고통을 최소화 하고 레거시 소프트웨어를 직접 만들지 않기 위해 주의를 기울여야 할 소프트웨어 시스템 설계 원칙
  - 운용성(operability)
    - 운영팀이 원활하게 운영할수 있게 쉽게 만들어라 
  - 단순성(simplicity)
    - 복잡도를 최대한 제거해 새로운 엔지니어가 시스템 이해하기 쉽게 만들어라
  - 발전성(evolvability)
    - 이후에 쉽게 시스템을 변경할 수 있게 하라. 
    - 동일어: 유연성(extensibility), 수정 가능성(modifiability), 적응성(plasticity)
- 신뢰성, 확장성을 달성하기 위한 쉬운 해결책은 없다. 그보다 운용성, 단순성, 발전성을 염두에 두고 시스템을 생각하려 노력해야 한다.

### 운용성
- 좋은 운영은 종종 나쁜 소프트웨어 제약을 피하는 대안이 될 수 있다. 하지만 좋은 소프트웨어라도 나쁘게 운영하면 작동을 신뢰할 수 없다.
- 운영 중 일부 측면은 자동화할 수 있고 또 자동화해야 한다. 그러나 자동화를 처음 설정하고 제대로 동작하는지 확인하는 일은 여전히 사람 몫이다.
- 좋은 운영성이란 동일하게 반복되는 태스크를 쉽게 수행하게끔 만들어 운영팀이 고부가가치 활동에 노력을 집중한다는 의미.
  - 좋은 모니터링으로 런타임 동작과, 시스템 내부 가시성 제공
  - 표준도구를 이용해 자동화와 통합을 위한 우수한 지원 제공
  - 개별 장비 의존성 회피. 장비 내리더라도 시스템 전체에 영향 주지 않고 운영 가능
  - 좋은 문서와 이해하기 쉬운 운영 모델
  - 만족할만한 기본동작, 필요할 때 기본값을 다시 정의할 수 있는 자유 부여
  - 자기회복이 가능하고 필요에 따라 관리자가 시스템 상태를 수동 제어 가능
  - 예측 가능하게 동작, 예기치 않은 상황 최소화
  
### 단순성
- 복잡도는 같은 시스템에서 작업하는 모든 사람의 진행을 느리게 하고 유지보수 비용을 증가시킨다. 
- 증상
  - 상태 공간의 급증
  - 모듈간 강한 커플링
  - 복잡한 의존성
  - 일관성 없는 naming과 용어
  - 임시방편으로 문제를 해결한 특수 사례
  
- 복잡도를 줄이면 유지보수성이 크게 향상. 단순성이 구축하려는 시스템의 핵심 목표여야 한다. 
- 단순하게 만드는 일이 기능을 줄인다는 의미는 아니다. 우발적 복잡도(accidental complexity)를 줄인다는 뜻일 수 있다.
- 우발적 복잡도는 소프트웨어가 풀어야 할 문제에 내재하고 있지 않고 구현에서만 발생하는 것으로 정의
    