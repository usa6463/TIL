# 파티셔닝

- 파티셔닝 사용 목적
  - 파티셔닝의 주된 이유는 확장성
  - 저장하고 처리할 데이터가 너무 많아져서 장비 한대로는 처리하는게 불가능해지면 필요
  
- 샤딩
    - 데이터를 파티션으로 쪼개는 작업
    - 데이터셋이 매우 크거나 질의 처리량이 높다면 사용
    - 각 파티션은 그 자체로 작은 데이터베이스가 됨.
    - 질의 실행시 각 노드에서 자신의 파티션에 해당하는 질의를 실행할수 있으므로, 노드의 추가로 질의 처리량 늘릴 수 있음.
  
- 파티셔닝과 복제
  - 보통 복제와 파티셔닝을 함께 적용해 각 파티션의 복사본을 여러 노드에 저장함
  
- 키-값 데이터 파티셔닝
  - 파티셔닝의 목적은 데이터와 질의 부하를 노드 사이에 고르게 분산 시키는 것
  - skew: 파티셔닝이 고르게 이뤄지지 않은 경우
  - 핫스팟: 불균형하게 부하가 높은 파티션
  - 핫스팟 회피를 위한 단순한 방법: 레코드 할당 노드 무작위 선택
    - 데이터가 노드들 사이에 고르게 분산
    - 해당 레코드가 어느 노드에 저장됐는지 알 수 없어서, 모든 노드에서 병렬적으로 질의 실행해야함.

  - 종류
    - 키 범위 기준 파티셔닝
      - 각 파티션에 연속된 범위의 키를 할당하는 방법
      - 키 범위 크기가 반드시 동일할 필요는 없다. 
      - 파티션 경계는 관리자가 수동으로 선택하거나 DB에서 자동으로 선택되게 할 수 있다
      - 파티션 내에서 키를 정렬된 순서로 정렬
      - 장점
        - 범위 스캔이 쉬움
        - 질의 하나로 관련 레코드 여러 개를 읽어올 수 있음
      - 단점
        - 특정한 접근 패턴이 핫스팟을 유발
          - 예를들어 타임스탬프가 키라면, 매일 특정 파티션만 과부하 걸리고 나머지 파티션은 유휴 상태일 수 있음

    - 해시 파티셔닝
      - 키의 파티션을 정할 때 해시 함수를 사용하는 방법
      - 파티션 경계는 크기가 동일하도록 나눌 수 있고, 무작위에 가깝게 선택할 수도 있다.
      - 일관성 해싱: 경계를 무작위로 나누는 방식. DB에선 실제로 작 동작하지 않아 현실에서 거의 사용안함. 
       
      - 장점
        - 키를 파티션 사이에 균일하게 분산시키는데 좋음
      - 단점
        - 범위 질의 효율적으로 실행 불가.
          - 인접했던 키들이 여러 파티션에 흩어져서 정렬순서가 유지되지 않는다.
  
    - 복합
      - 예시) 카산드라
      - 여러 칼럼을 포함하는 복합 기본키 지정 가능
      - 키의 첫 부분만 해싱 적용해 파티션 결정에 사용
      - 남은 칼럼은 데이터를 정렬하는 연쇄된 색인으로 사용
      - 첫번째 칼럼 제외 다른 칼럼에 대해서는 범위 스캔 효율적 실행 가능
  
- 작업부하 쏠림과 핫스팟 완화 방법
  - 사례) 항상 동일한 키를 읽고 쓰는 극단적인 상황
  - 현대 데이터 시스템은 크게 쏠린 작업 부하 자동 보정 못하므로, 애플리케이션에서 쏠림 완화 필요
  - 해결책
    - 키의 시작이나 끝에 임의의 숫자 추가
      - 임의의 10진수 두개만 붙이더라도 한 키에 대한 쓰기 작업이 100개의 다른 키로 균등하게 분산됨.
      - 단점
        - 읽기 실행시 추가적인 작업 필요
        - 100개의 키에 해당하는 데이터를 읽어서 조합해야함. 
      - 이 기법은 요청이 몰리는 소수의 키에만 적용하는게 타당함. 
  
- 파티셔닝과 보조 색인
  - 보조 색인: 레코드를 유일하게 식별하는 용도가 아니라, 특정한 값이 발생한 항목을 검색하는 수단.
  - 보조 색인은 파티션에 깔끔하게 대응되지 않는 문제점이 있음. 
  - 문서 기준 보조색인 파티셔닝
      - 각 파티션은 자신의 보조 색인을 유지
      - 다른 파티션에 어떤 데이터가 저장되는지 신경 쓰지 않는다.
      - 지역 색인(local index)라고도 함. 
      - 장점
        - 문서 쓰기시 한개의 파티션에만 영향줌.
      - 단점
        - 특정 값을 가진 문서를 찾고 싶다면 모든 파티션에 질의를 보내고 얻은 결과를 모아야 함.(스캐터/개더라고도 함.)
          - 스캐터/개더는 꼬리 지연 시간 증폭 발생하기 쉬움. 
  - 용어 기준 보조색인 파티셔닝
    - 모든 파티션의 데이터를 담당하는 전역 색인을 만들 수 있음
    - 한 노드에만 색인 저장할순 없음. 해당 노드가 병목이 되어 파티셔닝 목적을 해치기 때문
    - 찾고자 하는 용어에 따라 보조색인의 파티션이 결정됨. 용어 기준 파티셔닝(term-partitioned)
    - 세부 구현
      - 용어 자체 사용(범위 스캔 효율 높음, 특정 상황에서 skew 가능성 높음)
      - 용어의 해시값 사용(범위 스캔 효율 낮음, 특정 상황에서 skew 가능성 낮음)
      - 키 파티셔닝 때와 마찬가지로 위 2개 방식은 범위 스캔과 고른 분산 사이의 트레이드오프 가짐
    - 장점
      - 읽기가 효율적
      - 스캐터/개더 실행할 필요 없이 원하는 용어를 포함하는 파티션으로 요청 보내면 됨.
    - 단점
      - 쓰기가 느리고 복잡함.
      - 문서 쓰기시 보조 색인의 용어에 따라, 여러 파티션에 영향줄 수 있으므로.(문서 내 키로 color, make 등이 있을 수 있고 이를 위한 보조색인이 여러 파티션에 나눠져 있을 수 있음)
      - 전역 보조 색인은 대개 비동기로 갱신되고, 항상 최신 상태가 아닐 수 있다

- 파티션 재균형화(rebalancing)
  - 클러스터에서 한 노드가 담당하던 부하를 다른 노드로 옮기는 과정 
  - DB에 변화가 새기면 데이터와 요청이 한 노드에서 다른 노드로 옮겨져야 함
    - DB 노드에 CPU를 추가
    - 데이터셋 저장에 사용할 디스크와 램 추가 등
  - 재균형화 후 만족시킬 것으로 기대되는 요구사항
    - 부하가 클러스터 내 노드 사이에 균등하게 분배됨
    - 재균형화 도중에도 DB는 읽기 쓰기 요청 받을 수 있어야 함
    - 노드 사이에 데이터가 필요 이상으로 옮겨지면 안된다.(재균형화가 빨리 실행되고, 디스크 I/O 부하 최소화 하도록)
  - 쓰면 안되는 방법
    - 해시값에 모드 N 연산 실행
      - 문제: 노드 개수 N이 바뀌면 대부분의 키가 파티션 옮겨야 함.
  - 전략
    - 파티션 개수 고정
      - 파티션을 노드 대수보다 많이 만들고, 각 노드에 여러 파티션을 할당
      - 노드 추가: 새 노드로 기존 노드에 있던 파티션 몇개를 뺏어옴. 
      - 노드 제거: 추가의 반대 과정 실행
      - 할당 변경 중 읽기/쓰기 요청: 기존에 할당된 파티션을 사용
      - 적절한 파티션 크기 설정 필요
        - 고정 파티션 DB는 파티션 불할 지원하지 않는 경우가 많음.
        - 미래에 증가될 것을 수용하기에 충분히 높은 값 선택 필요
        - 너무 큰 수는 개별 파티션 관리 오버헤드 있을 수 있음
        - 너무 크지도, 작지도 않은 적당한 크기가 성능이 가장 좋음
    - 동적 파티셔닝
      - 파티션 크기가 설정된 값을 넘어서면 파티션을 두 개로 쪼개 각각 원래 파티션의 절반 정도 데이터가 포함되게 함.
      - 키 범위 파티셔닝 DB에서 주로 사용(skew가 있을 수 있으므로). 
          - 해시 파티셔닝도 지원됨.
      - 사전분할(pre splitting)
        - 초기 파티션 집합 설정하는 기능
        - 사전 분할이 없다면
          - 초기에는 파티션 경계에 대한 사전 정보가 없어서 파티션이 1개
          - 이 경우 모든 쓰기 요청이 하나의 노드에서 실행되고 다른 노드는 유휴 상태가 된다
        
    - 노드 비례 파티셔닝
      - 파티션 개수가 노드 대수에 비례하게 하는 방식
        - = 노드당 할당된느 파티션 개수 고정
      - 새 노드 추가
          - 고정된 개수의 파티션을 무작위로 선택해 분할
            - 무작위 선택하더라도 여러 파티션에 대해 평균적으로 보면, 새 노드는 기존 노드들이 담당하던 부하에서 균등한 몫을 할당 받는다
          - 각 분할된 파티션의 절반은 그대로 두고 다른 절반은 새 노드에 할당
  - 운영
    - 완전 자동
      - 일상적인 유지보수에 손이 덜 간다
      - 예측하기 어렵다
    - 재균형화 과정에 사람이 개입하는게 좋을 수 있음. 완전 자동 처리보단 느릴 수 있지만 운영상 예상치 못한 일 방지에 도움
  
- 요청 라우팅
  - 클라이언트가 요청 보낼 때 어떤 노드에 접속해야하는지 확인하는 방법
  - service discovery의 일종
  - 접근법
    1. 아무 노드에 접속. 요청을 적용할 파티션이 있다면 거기서 처리하고 없다면 올바른 노드로 요청을 전달
    2. 라우팅 계층에서 적절한 노드로 전달
    3. 클라이언트가 파티셔닝 방법과, 파티션이 어떤 노드에 할당됐는지 알고 있게 함
  - 모든 접근법에 대한 핵심 문제: 라우팅 결정을 내리는 구성요소가(노드, 라우팅 계층, 클라이언트) 노드에 할당된 파티션의 변경을 어떻게 아는가?
    - 코디네이션 서비스
      - ex) zookeeper
      - 클러스터 메타 데이터를 추적
      - 몽고DB 등은 자체적인 config server를 사용
      - 2, 3번 접근법에서 사용
    - 가십 프로토콜(gossip protocol)
      - 클러스터 상태 변화를 노드사이에 퍼뜨리는 방법
      - 외부 코디네이션 서비스에 의존하지 않음
      - 대신 DB 노드에 복잡성을 더함
      - 1번 접근법에서 사용