# 파티셔닝

- 파티셔닝 사용 목적
  - 파티셔닝의 주된 이유는 확장성
  - 저장하고 처리할 데이터가 너무 많아져서 장비 한대로는 처리하는게 불가능해지면 필요
  
- 샤딩
    - 데이터를 파티션으로 쪼개는 작업
    - 데이터셋이 매우 크거나 질의 처리량이 높다면 사용
    - 각 파티션은 그 자체로 작은 데이터베이스가 됨.
    - 질의 실행시 각 노드에서 자신의 파티션에 해당하는 질의를 실행할수 있으므로, 노드의 추가로 질의 처리량 늘릴 수 있음.
  
- 파티셔닝과 복제
  - 보통 복제와 파티셔닝을 함께 적용해 각 파티션의 복사본을 여러 노드에 저장함
  
- 키-값 데이터 파티셔닝
  - 파티셔닝의 목적은 데이터와 질의 부하를 노드 사이에 고르게 분산 시키는 것
  - skew: 파티셔닝이 고르게 이뤄지지 않은 경우
  - 핫스팟: 불균형하게 부하가 높은 파티션
  - 핫스팟 회피를 위한 단순한 방법: 레코드 할당 노드 무작위 선택
    - 데이터가 노드들 사이에 고르게 분산
    - 해당 레코드가 어느 노드에 저장됐는지 알 수 없어서, 모든 노드에서 병렬적으로 질의 실행해야함.

  - 종류
    - 키 범위 기준 파티셔닝
      - 각 파티션에 연속된 범위의 키를 할당하는 방법
      - 키 범위 크기가 반드시 동일할 필요는 없다. 
      - 파티션 경계는 관리자가 수동으로 선택하거나 DB에서 자동으로 선택되게 할 수 있다
      - 파티션 내에서 키를 정렬된 순서로 정렬
      - 장점
        - 범위 스캔이 쉬움
        - 질의 하나로 관련 레코드 여러 개를 읽어올 수 있음
      - 단점
        - 특정한 접근 패턴이 핫스팟을 유발
          - 예를들어 타임스탬프가 키라면, 매일 특정 파티션만 과부하 걸리고 나머지 파티션은 유휴 상태일 수 있음

    - 해시 파티셔닝
      - 키의 파티션을 정할 때 해시 함수를 사용하는 방법
      - 파티션 경계는 크기가 동일하도록 나눌 수 있고, 무작위에 가깝게 선택할 수도 있다.
      - 일관성 해싱: 경계를 무작위로 나누는 방식. DB에선 실제로 작 동작하지 않아 현실에서 거의 사용안함. 
       
      - 장점
        - 키를 파티션 사이에 균일하게 분산시키는데 좋음
      - 단점
        - 범위 질의 효율적으로 실행 불가.
          - 인접했던 키들이 여러 파티션에 흩어져서 정렬순서가 유지되지 않는다.
  
    - 복합
      - 예시) 카산드라
      - 여러 칼럼을 포함하는 복합 기본키 지정 가능
      - 키의 첫 부분만 해싱 적용해 파티션 결정에 사용
      - 남은 칼럼은 데이터를 정렬하는 연쇄된 색인으로 사용
      - 첫번째 칼럼 제외 다른 칼럼에 대해서는 범위 스캔 효율적 실행 가능
  
- 작업부하 쏠림과 핫스팟 완화 방법
  - 사례) 항상 동일한 키를 읽고 쓰는 극단적인 상황
  - 현대 데이터 시스템은 크게 쏠린 작업 부하 자동 보정 못하므로, 애플리케이션에서 쏠림 완화 필요
  - 해결책
    - 키의 시작이나 끝에 임의의 숫자 추가
      - 임의의 10진수 두개만 붙이더라도 한 키에 대한 쓰기 작업이 100개의 다른 키로 균등하게 분산됨.
      - 단점
        - 읽기 실행시 추가적인 작업 필요
        - 100개의 키에 해당하는 데이터를 읽어서 조합해야함. 
      - 이 기법은 요청이 몰리는 소수의 키에만 적용하는게 타당함. 
  
- 파티셔닝과 보조 색인
  - 보조 색인: 레코드를 유일하게 식별하는 용도가 아니라, 특정한 값이 발생한 항목을 검색하는 수단.
  - 보조 색인은 파티션에 깔끔하게 대응되지 않는 문제점이 있음. 
  - 문서 기준 보조색인 파티셔닝
      - 각 파티션은 자신의 보조 색인을 유지
      - 다른 파티션에 어떤 데이터가 저장되는지 신경 쓰지 않는다.
      - 지역 색인(local index)라고도 함. 
      - 장점
        - 문서 쓰기시 한개의 파티션에만 영향줌.
      - 단점
        - 특정 값을 가진 문서를 찾고 싶다면 모든 파티션에 질의를 보내고 얻은 결과를 모아야 함.(스캐터/개더라고도 함.)
          - 스캐터/개더는 꼬리 지연 시간 증폭 발생하기 쉬움. 
  - 용어 기준 보조색인 파티셔닝
    - 모든 파티션의 데이터를 담당하는 전역 색인을 만들 수 있음
    - 한 노드에만 색인 저장할순 없음. 해당 노드가 병목이 되어 파티셔닝 목적을 해치기 때문
    - 찾고자 하는 용어에 따라 보조색인의 파티션이 결정됨. 용어 기준 파티셔닝(term-partitioned)
    - 세부 구현
      - 용어 자체 사용(범위 스캔 효율 높음, 특정 상황에서 skew 가능성 높음)
      - 용어의 해시값 사용(범위 스캔 효율 낮음, 특정 상황에서 skew 가능성 낮음)
      - 키 파티셔닝 때와 마찬가지로 위 2개 방식은 범위 스캔과 고른 분산 사이의 트레이드오프 가짐
    - 장점
      - 읽기가 효율적
      - 스캐터/개더 실행할 필요 없이 원하는 용어를 포함하는 파티션으로 요청 보내면 됨.
    - 단점
      - 쓰기가 느리고 복잡함.
      - 문서 쓰기시 보조 색인의 용어에 따라, 여러 파티션에 영향줄 수 있으므로.(문서 내 키로 color, make 등이 있을 수 있고 이를 위한 보조색인이 여러 파티션에 나눠져 있을 수 있음)
      - 전역 보조 색인은 대개 비동기로 갱신되고, 항상 최신 상태가 아닐 수 있다

- 파티션 재균형화
  - 
  
- 파티션 라우팅
