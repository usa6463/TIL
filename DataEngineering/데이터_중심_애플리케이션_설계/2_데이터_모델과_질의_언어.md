# 데이터 모델과 질의 언어

- 데이터 모델은 소프트웨어가 어떻게 작성됐는지 뿐 아니라 해결하려는 문제를 어떻게 생각해야 하는지에 대해서도 지대한 영향
- 대부분의 app은 하나의 데이터 모델을 다른 데이터 모델 위에 계층을 둬서 만듬. (하드웨어 -> DB -> 데이터 구조 -> 애플리케이션)
- 각 계층의 핵심적인 문제는 데이터 모델을 표현하는 방법. ex) 데이터 구조는 JSON, XML, RDB 테이블, 그래프 모델 같은 범용 데이터 모델로 표현
- 이번 챕터는 다양한 범용 데이터 모델을 살펴본다. 

## 관계형 모델과 문서 모델
- 관계형 모델
  - 데이터는 관계로 구성되고 각 관계는 순서없는 튜플 모음이다.
  
- NoSQL의 탄생
  - 관계형 모델의 우위를 뒤집으려는 최신 시도
  - NoSQL 채택의 원동력
    - 대규모 데이터셋, 높은 쓰기 처리량 달성을 RDB보다 쉽게 할 수 있는 확장성
    - 상용 DB 보다 무료 오픈소스 소프트웨어에 대한 선호도 확산
    - 특수 질의 동작
    - RDB의 스키마 제한에 대한 불만과 더 동적이고 표현력 풍부한 데이터 모델에 대한 바람.
  
- 다중 저장소 지속성(polyglot persistence)
  - 한 사용 사례에 맞는 최적의 기술 선택은 또 다른 사용 사례에 맞는 최적의 선택과는 다를 수 있다.
  - 가까운 미래에는 RDB가 폭넓은 다양함을 가진 비관계형 데이터 스토어와 함께 사용될 것이다. 
  
- 객체 관계형 불일치
  - APP 코드와 데이터베이스 모델 객체 사이에 전환 계층이 필요 (= 임피던스 불일치)
  - ORM 프레임워크(하이버네이트 같은)는 전환계층의 boilerplate code 양을 줄이지만 모델 간 차이 완벽히 숨길 수 없다.
  
- one-to-many 관계
  - 하나의 객체에 여러개의 속성이 있을 수 있다. (ex. 사람들은 경력에 넣을 직업, 연락처, 학력 기간 등이 하나 이상이다.)
  - 표현 방법
    - 정규화 표현
      - 전통적인 SQL 모델에서 사용
      - 속성을 개별 테이블에 넣고, 외래 키로 객체 참조
      - multi table
    - 구조화된 데이터 타입(data type), XML 데이터 지원
      - SQL 표준 마지막 버전에서 지원
      - 단일 로우에 다중 값 저장 가능하고 문서 내 질의와 색인 가능
      - DB2, MS SQL, Postgresql 등 DB 마다 제각각 다양한 형태로 지원.
    - JSON, XML 문서로 부호화해 DB의 텍스트 컬럼에 저장
      - 애플리케이션이 구조와 내용을 해석
      - 부호화된 컬럼의 값을 질의하는데 DB 사용 불가
      - multi table 스키마보다 더 나은 지역성(locality)을 가진다. 
        - join 이나 다중 질의 없이 관련 정보가 한 곳에 있어 질의 하나로 충분
    
  - 트리구조로 표현된다. 
  
- 다대일과 다대다 관계
  - 컬럼 값을 id 형태로 저장
    - 장점
      - 프로필 간 일관된 스타일과 철자
      - 모호함 회피
      - 갱신이 편리(정치적 사건 등으로 도시 이름이 변경 되는 경우)
      - 현지화 지원 (보는 사람의 언어로 표시 가능)
      - 더 나은 검색
    - 중복의 문제
      - ID를 사용하는 경우 사람에게 의미 있는 정보는 한 곳에만 저장하고 그것을 참조하는 모든 것은 ID를 사용
      - 텍스트를 직접 저장한다면 그것을 사용하는 모든 레코드에서 사람을 의미하는 정보를 중복해서 저장한다.
    - 변경의 필요 없음
      - ID 자체는 의미가 없어서 변경할 필요가 없음. 즉 식별 정보는 변경해도 ID는 동일하게 유지할 수 있다
      - 정보가 중복돼 있으면 모든 중복항목을 변경해야 함
      - 이는 쓰기 오버헤드와 불일치 위험. 
      - 이런 중복을 제거하는 일이 DB 정규화 이면에 놓인 핵심 개념
  - 다대일(many-to-one)
    - 중복된 데이터 정규화 하려면 필요
    - 문서 모델에 적합하지 않음. 
      - 조인에 대한 지원이 약함
      - DB가 조인을 지원하지 않으면 DB에 대한 다중 질의를 만들어서 조인 흉내 내야 함. 
    - join-free 문서 모델에 적합하더라도 app에 기능을 추가하면서 점차 상호 연결되는 경향 있음.
    - 예
      - 추천서 작성 기능 추가 시, 각 추천서들(many)이 추천인(one)을 참조하는 것으로 추천인의 사진 이름 등이 같이 보여짐.
  
- 문서 데이터베이스는 역사를 반복하고 있나?
  - 1970년대 비즈니스 데이터 처리를 위해 많이 사용한 DB로 IMS가 있었고 IMS는 계층 모델을 사용함
  - 계층 모델은 JSON모델과 유사
  - 계층 모델은 일대다 관계에선 잘 동작하지만 다대다 관계 표현이 어렵고 조인 지원하지 않음.
  - 계층 모델의 한계를 해결하기 위해 관계형 모델, 네트워크 모델이 있었음. 
  - 네트워크 모델
    - 코다실(CODASYL) 위원회에서 표준화. 코다실 모델이라고도 함
    - 계층 모델을 일반화한다. 
      - 계층 모델의 트리 구조에서 모든 레코드는 정확하게 하나의 부모가 있음.
      - 네트워크 모델의 각 레코드는 다중 부모가 있을 수 있다.
      - 레코드간 연결은 외래 키보다는 프로그래밍 언어의 포인터와 비슷하다.
      - 레코드에 접근하는 유일한 방법은 최상위 레코드에서부터 연속된 연결 경로를 따르는 방법
      - 만약 레코드가 다중 부모를 가진다면(즉, 다른 레코드에서 다중으로 유입된 포인터) 다양한 관계를 모두 추적해야 한다.
        - 이 방식은 n차원 데이터 공간을 항해하는 것과 같다.
      - 데이터 베이스 질의와 갱신을 위한 코드가 복잡하고 유연하지 못한 문제 있음
        - 원하는 데이터에 대한 경로가 없다면 어려운 상황에 놓인다
        - 접근 경로를 변경할 수 있지만 수작업 DB질의 코드를 살펴봐야 하고 새로운 접근 경로 다루기 위해 재작성 필요
  
  - 관계형 모델
    - 관계형 모델이 하는 일은 알려진 모든 데이터를 배치하는 것
    - 테이블은 튜플(로우)의 컬렉션이 전부다
    - 질의 최적화기(query optimizer)는 질의어 어느 부분을 어떤 순서로 실행할지 결정하고 사용할 색인을 자동을 결정한다.
    - 새로운 방식으로 데이터에 질의하고 싶은 경우 새로운 색인을 선언하기만 하면 질의는 자동으로 가장 적합한 색인을 사용한다.
  
  - 문서 데이터베이스와의 비교
    - 문서 데이터베이스는 별도 테이블이 아닌 상위 레코드 내에 중첩된 레코드를 저장한다. (map, key-value)
    - 다대일과 다대다 관계 표현시 관계형 데이터베이스와 문서 데이터베이스는 근본적으로 다르지 않다.
    - 관계형 모델에선 외래키라 부르고, 문서 모델에선 문서참조(document reference)라 부른다. 
      - 조인이나 후속 질의를 사용해 읽기 시점에 확인
  
- 관계형 데이터베이스와 오늘날의 문서 데이터베이스
  - 문서 데이터 모델 선호 이유
    - 스키마 유연성
    - 지역성에 기인한 더 나은 성능
    - 일부 app의 경우 app에서 사용한느 데이터 구조와 더 가깝기 때문
  - 관계형 모델 선호 이유
    - 조인
    - 다대일과 다대다 더 잘 지원
  - 어떤 데이터 모델이 app 코드를 더 간단히 하는가?
    - app 데이터가 문서와 비슷한 구조(일대다 관계 트리. 보통 한번에 전체 트리 적재)
      - 문서 모델이 적합
      - 여러 테이블로 찢는(shredding) 관계형 기법은 다루기 힘든 스키마와 불필요하게 복잡한 app 코드 발생
    - 문서 모델
      - 중첩 항목 바로 참조 불가. "사용자 251의 직위 목록의 두 번쨰 항목"과 같이 표현해야함. 너무 깊게 중첩되지 않으면 문제 되지 않음.
      - 미흡한 조인 지원은 app에 따라 문제가 될 수 있고 아닐 수도 있다. 
      - app이 다대다 관계 사용하면 복잡한 app 코드와 나쁜 성능으로 이어질 수 있다.
    - 상호 연결이 많은 데이터를 쓰는 app은 관계형 모델이 무난하고, 그래프 모델은 매우 자연스럽다
  
- 문서 모델에서의 스키마 유연성
  - 문서 데이터베이스와 RDB에서 지원하는 JSON은 스키마 강요하지 않음. 
  - 쓰기 스키마(schema-on-write)
    - 스키마는 명시적이고 DB는 쓰여진 모든 데이터가 스키마를 따르고 있음을 보장
    - 정적 타입 확인과 유사
  - 읽기 스키마(schema-on-read)
    - 데이터 구조는 암묵적이고 데이터를 읽을 때에만 해석된다.
    - 동적(런타임) 타입 확인과 유사
    - 컬렉션 안의 항목이 어떤 이유로 모두 동일한 구조가 아닐 때 유리. 
      - 다른 여러 유형의 오브젝트가 있고 각 유형의 오브젝트별로 자체 테이블에 넣는건 실용적이지 않다.
      - 사용자가 제어할 수 없고 언제나 변경 가능한 외부 시스템에 의해 데이터 구조가 결정된다.
  - 문서 DB는 스키마리스가 아니라 읽기 스키마이다. 
  - 접근 방식 간 차이는(읽기, 쓰기) app이 데이터 타입을 변경하고자 할때 뚜렷이 나타난다
    - ex) 하나의 필드에 사용자의 전체 이름을 저장하고 있지만 성과 이름을 분리하고자 할 때
      - 문서 DB
          - 새로운 필드를 가진 새로운 문서 작성 시작하고, app에선 예전 문서를 읽는 경우를 처리하는 코드 추가
      - 정적 타입 DB
        - migration 수행(ALTER, UPDATE 문)
        - 느리고 중단시간 요구
        - app이 first_name이 기본값인 null로 설정되게 남겨두고 문서 DB처럼 읽는 시점에 채울수도 있다
  - 모든 레코드가 동일한 구조라서 예상 가능하다면 스키마가 있는게 문서화와 구조를 강제하는데 좋다. 
  

