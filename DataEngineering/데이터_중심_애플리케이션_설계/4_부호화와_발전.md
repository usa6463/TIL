# 부호화와 발전

- app은 필연적으로 시간이 지남에 따라 변함
- app 기능을 변경하려면 저장하는 데이터도 변경 필요
- 데이터 타입이나 스키마가 변경될 때 app 코드에 대한 변경이 종종 필요
- 하지만 대규모 app에서 코드 변경은 대개 즉시 반영할 수 없다.
    - 백엔드: rolling upgrade
    - 프론트엔드: 사용자에 좌우됨. 어떤 사용자는 한동안 업데이트를 설치하지 않을 수도 있다.
- 예전 버전의 코드와 새로운 코드, 이전의 데이터 타입과 새로운 데이터 타입이 시스템에 동시에 공종할 수 있다는 의미 
    - 양방향 호환성 필요
        - 하위 호환성
            - 새로운 코드는 예전 코드가 기록한 데이터를 읽을 수 있어야 한다.
        - 상위 호환성
            - 예전 코드는 새로운 코드가 기록한 데이터를 읽을 수 있어야 한다.
- 이번 장에서 살펴볼 요소
    - 데이터 부호화를 위한 다양한 형식
        - JSON, XML, 프로토콜 버퍼, Thrift, Avro
    - 예전 버전과 새로운 버전의 데이터와 코드가 공종하는 시스템 지원 방법
    - 여러 메시지 전달 시스템(REST, RPC, actor, message queue)에서 다양한 데이터 부호화 형식이 데이터 저장과 통신에 어떻게 사용되는지 살펴본다.

## 데이터 부호화 형식
- 프로그램은 최소 두가지 형태로 표현된 데이터 사용한다
    - 인메모리 표현
        - ex. 객체, 구조체, 목록, 배열 등
        - CPU에서 효율적으로 접근하고 조작할 수 있게 보통 포인터를 이용해 최적화됨
    - 바이트열
        - ex. JSON
        - 데이터를 파일에 쓰거나 네트워크를 통해 전송하기 위함
    - 두 가지 표현 사이에 일종의 전환 필요
        - 부호화(직렬화 또는 마샬링): 인메모리 표현 -> 바이트열
        - 복호화(파싱, 역직렬화, 언마샬링): 바이트열 -> 인메모리 표현
    
- 언어별 형식
    - 프로그래밍 언어에 부호화 기능 내장
        - 장점
            - 최소한의 추가 코드로 인메모리 객체 저장하고 복원 가능
        - 단점
            - 특정 프로그래밍 언어에 종속
            - 보안 취약점
                - 공격자가 임의의 클래스를 인스턴스화 할 수 있음. 
            - 상위, 하위 호환성의 문제
            - 효율성
                - ex. 자바 내장 직렬화는 성능이 좋지 않고 비대해지는 부호화로 유명
    
- JSON과 XML, 이진 변형
    - 표준화된 부호화 형식: JSON, XML, CSV
        - 텍스트 형식이라 어느 정도 사람이 읽을 수 있음
    - 문제점
        - 수(number)의 부호화 애매함
            - XML, CSV : 수와 숫자로 구성된 문자열 구분 불가능
            - JSON: 정수와 부동소수점 수를 구별하지 않고 정밀도를 지정하지 않는다.
                - 큰수 다룰 때 문제
                - 2^53 보다 큰 정수는 부동소수점 수에서는 정확하게 표현 불가
                - 트위터는 API에서 반환된 JSON에 수로 한번, 10진 문자열로 한번 트윗 ID를 포함시켜 이 문제 해결(트윗 ID로 64비트 숫자 사용)
        - 이진 문자열 지원하지 않음(JSON, XML)
            - Base64 사용해 텍스트로 부호화 하여 제한을 회피
            - 값이 Base64로 부호화 됐기 때문에 해석해야 한다는 사실을 스키마로 표현
            - 데이터 크기가 33% 증가한다. 
        - XML, JSON 스키마
            - XML, JSON 지원하는 스키마 언어 강력하지만 익히고 구현하기 난해함.
            - XML, JSON 스키마를 사용하지 않는 애플리케이션은 필요한 부호화/복호화 로직을 하드코딩해야 할 수 있음
        - CSV의 스키마 부재, 모호한 형식
            - 각 로우와 칼럼의 의미 정의는 애플리케이션이 해야함
            - 새로운 로우나 칼럼 추가 시 수동 변경 처리 필요
            - 이스케이핑 규칙을 공식적으로 규정 했지만 모든 파서가 규칙을 정확하게 구현하지 않는다. 
    - 위의 문제점에도 불구하고 데이터 교환 형식으로 사용하기 충분하다
        - 사람들이 사용에 동의만 한다면 얼마나 읽기 쉽고 효율적인 형식인지는 중요하지 않음
        - 무엇이든 다른 조직의 동의를 얻는 어려움은 대부분의 다른 문제보다 더 크기 때문
    
- 이진 부호화 
    - 조직 내에서만 사용하는 데이터라면 최소공통분모 부호화 형식(lowest-common-denominator encoding format) 사용 부담감이 덜하다.
    - 작은 데이터셋으론 부호화 형식 선택의 이득이 적지만 테라바이트 정도면 큰 영향 미친다
    - JSON은 XML 보다 덜 장황하지만 이진 형식과 비교하면 둘 다 훨씬 많은 공간 차지한다.
    - 이진 부호화 ex) 메시지팩, BSON, BJSON, ... 
    - 스키마를 지정하지 않기 때문에 부호화된 데이터 안에 모든 객체의 필드 이름을 포함해야 한다.
    
- 스리프트와 프로토콜 버퍼
    - 같은 원리를 기반으로 한 이진 부호화 라이브러리 (스리프트는 페이스북, 프로토콜 버퍼는 구글에서 개발)
    - 부호화할 데이터를 위한 스키마 필요
    - 스리프트의 이진 부호화 형식
        - 바이너리 프로토콜
            - 필드 이름이 없음
            - 부호화된 데이터는 숫자와 같은 필드 태그 사용
                - 필드 태그는 스키마에 명시되어 있음
        - 컴팩트 프로토콜 
            - 의미상으로는 바이너리 프로토콜과 같음. 
            - 필드 타입과 태그 숫자를 단일 바이트로 줄이고 가변 길이 정수를 사용해서 부호화 
    - 프로토콜 버퍼
        - 스리프트의 컴팩트 프로토콜과 매우 유사
    
    - 필드 태그와 스키마 발전
        - 스키마 발전: 스키마는 필연적으로 시간이 지남에 따라 변하고, 이를 스키마 발전이라고 함
        - 규칙
            - 스키마에서 필드 이름 변경 가능
                - 부호화된 데이터는 필드 이름 참조하지 않음
            - 필드 태그는 변경 불가능
                - 기존의 모든 부호화된 데이터 인식 불가능하게 할 수 있으므로
            - 새로운 필드 추가할 때 required로 설정 불가(optional이거나 default값 가져야함)
            - 필드 삭제
                - optional 필드만 삭제 가능
                - 같은 태그 번호는 절대 다시 사용 불가
          
        - 상위 호환
            - 예전 코드에서 새로운 코드로 기록한 데이터 읽는 경우
            - 예전 코드가 인식 불가능한 태그 번호 가진 필드가 있으면 데이터 타입 주석 참조하여 건너 뜀
          
        - 하위 호환
            - 신규 코드에서 예전 데이터 읽는 경우
            - 태그번호가 계속 같은 의미 가지므로 새로운 코드가 예전 데이터 항상 읽을 수 있음.
    
    - 데이터 타입과 스키마 발전
        - 필드의 데이터 타입을 변경할 순 있지만 값이 정확하지 않거나 잘릴 위험 존재함
        - 프로토콜 버퍼
            - 목록이나 배열 데이터 타입이 없고 repeated 표시자가 있음(required, optional과 함께 세번째 옵션)
            - repeated 필드의 부호화는 레코드에 단순히 동일한 필드 태그가 여러 번 나타남.
                - 이로 인해 단일값인 optional 필드를 다중 값인 repeated 필드로 변경해도 문제 없음
                - 이전 데이터를 읽은 새로운 코드(상위 호환성): 0이나 1개의 엘리먼트가 있는 목록으로 보게됨
                - 새로운 데이터를 읽는 예전 코드(하위 호환성): 목록의 마지막 엘리먼트만 보게 됨.
        - 스리프트
            - 전용 목록 데이터타입이 있음.
            - 목록 데이터 타입은 엘리먼트의 데이터 타입을 매개변수로 받음. 
            - protobuf와 다르게 단일 값에서 다중 값으로의 변경 허용하지 않음
            - 중첩된 목록 지원하는 장점 존재
    
- 아브로
    - 스리프트가 하둡의 사용 사례에 적합하지 않아 2009년 하둡의 하위 프로젝트로 시작됨.
    - 두 개의 스키마 언어 가짐
        - Avro IDL
            - 사람이 편집할 수 있음. 
        - JSON 기반 언어
            - 기계가 더 쉽게 읽을 수 있음. 
    - 바이트열
        - 필드나 데이터 타입을 식별하기 위한 정보가 없음. 
        - 스키마에 나타난 순서대로 필드를 살펴보고 스키마를 이용해 각 필드의 데이터 타입을 미리 파악해야 함
            - 데이터를 읽는 코드가 데이터를 기록한 코드와 정확히 같은 스키마 사용해야 올바르게 복호화 가능
    
    - 쓰기 스키마와 읽기 스키마
        - 쓰기 스키마: 부호화할 때 사용
        - 읽기 스키마: 복호화시 사용
        - 핵심 아이디어: 쓰기 스키마와 읽기 스키마가 동일하지 않아도 되며 호환 가능하면 된다
        - 쓰기 스키마와 읽기 스키마는 필드 순서가 달라도 문제 없음
            - 이름으로 필드를 일치
        - 데이터 읽는 코드
            - 읽기 스키마에는 없고 쓰기 스키마에 존재하는 필드 만나면 해당 필드 무시
            - 쓰기 스키마에는 없고 읽기 스키마에 존재하는 필드는 기본 값으로 채움
    
    - 스키마 발전 규칙
        - 상위 호환성: new 쓰기 스키마, old 읽기 스키마
        - 하위 호환성: new 읽기 스키마, old 쓰기 스키마
        - 규칙
            - 기본값이 있는 필드만 추가하거나 삭제 가능
            - 필드에 널을 허용하려면 유니온 타입 사용해야 함. 
                - ex) union { null, long, string } field;
                - 모든 널 가능 값을 갖기보다 장황하지만 널일 수 있는 것과 널일 수 없는 것이 명확해서 버그 막는데 도움
            - 필드의 데이터 타입 변경 가능
            - 필드 이름 변경 가능
                - 읽기 스키마는 필드 이름의 별칭 포함할 수 있음
                - 별칭에 예전 쓰기 스키마 필드 이름 매치 가능
                - 필드 이름 변경은 하위 호환성 있지만 상위 호환성 없음
                - 유니온 타입에 엘리먼트 추가 하는 것은 하위 호환성 있지만 상위 호환성 없음
    
    - 그러면 쓰기 스키마는 무엇인가?
        - 읽기가 특정 데이터를 부호화한 쓰기 스키마를 아는 방법
            - 많은 레코드가 있는 대용량 파일
                - 파일 시작 부분에 한 번만 쓰기 스키마 포함
                - 레코드들은 모두 동일한 스키마로 부호화 됨
            - 개별적으로 기록된 레코드를 가진 데이터베이스
                - 모든 부호화된 레코드의 시작 부분에 버전 번호를 포함하고 DB에서 스키마 버전 목록 유지
                - 읽기는 레코드 가져와 버전 번호 추출하고 DB에서 버전 번호에 해당 하는 쓰기 스키마 가져옴
                - DB에서 모든 레코드가 동일한 스키마 가진다고 가정할 수 없는 경우 사용
            - 네트워크 연결을 통해 레코드 보내기
                - 두 프로세스가 양방향 네트워크 연결 통해 통신할 때
                - 연결 설정에서 스키마 버전 합의 가능
                - 아브로 RPC 프로토콜이 이처럼 동작
    
    - 동적 생성 스키마
        - protobuf와 스리프트 대비 아브로 방식의 장점 한 가지: 스키마에 태그 번호가 없음
        - 이로인해 아브로는 동적 생성 스키마에 더 친숙함.
        - ex) RDB의 데이터를 파일로 덤프할 때
            - DB의 스키마가 변경되면 (ex. 칼럼 한개 추가하고, 다른 칼럼 하나 삭제한 경우)
                - 새로운 아브로 스키마 생성하고 데이터 내보냄
                - 이 과정에서 스키마 변경에 신경 쓸 필요가 없다. (스키마 변경이 실행될 때 마다 간단하게 수행 가능하다고 함.)
                - 새로운 데이터 파일을 읽는 사람은 레코드 필드가 변경된 사실을 알게 되지만 필드는 이름으로 식별되기 때문에 갱신된 쓰기 스키마는 여전히 이전 읽기 스키마와 매치 가능하다.
        - 이에 반해 스리프트나 프로토콜 버퍼를 위 용도와 같이 사요하면 필드 태그를 수동으로 할당해야 함.
            - 자동으로 할 수 있지만 스키마 생성자는 이전에 사용된 필드 태그가 할당되지 않게끔 조심해야 한다고함
    
    - 코드 생성과 동적 타입 언어
        - 스리프트와 프로토콜 버퍼는 코드 생성에 의존
            - 코드 생성: 프로그래밍 언어로 스키마를 구현한 코드 생성하는 것
            - 자바, C++ 같은 정적 타입 언어에서 유용
                - 복호화된 데이터를 위해 효율적인 인메모리 구조 사용 가능
                - IDE에서 타입 확인과 자동 완성 가능
        - 동적 타입
            - JS, ruby, python 같은 동적 타입 프로그래밍 언어에선 만족시킬 컴파일 시점의 타입 검사기가 없기 때문에 코드 생성이 중요하지 않다고 함. 
            - 아브로는 정적 타입 언어를 위한 코드 생성을 선택적으로 제공
            - 객체 컨테이너 파일이 있다면 아브로 라이브러리를 사용해 JSON 파일 보듯이 볼 수 있음.
                - 이 파일은 필요한 메타 데이터를 모두 포함하기 때문에 자기 기술적(self-describing)임.
    
    - 