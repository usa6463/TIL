# 부호화와 발전

- app은 필연적으로 시간이 지남에 따라 변함
- app 기능을 변경하려면 저장하는 데이터도 변경 필요
- 데이터 타입이나 스키마가 변경될 때 app 코드에 대한 변경이 종종 필요
- 하지만 대규모 app에서 코드 변경은 대개 즉시 반영할 수 없다.
    - 백엔드: rolling upgrade
    - 프론트엔드: 사용자에 좌우됨. 어떤 사용자는 한동안 업데이트를 설치하지 않을 수도 있다.
- 예전 버전의 코드와 새로운 코드, 이전의 데이터 타입과 새로운 데이터 타입이 시스템에 동시에 공종할 수 있다는 의미 
    - 양방향 호환성 필요
        - 하위 호환성
            - 새로운 코드는 예전 코드가 기록한 데이터를 읽을 수 있어야 한다.
        - 상위 호환성
            - 예전 코드는 새로운 코드가 기록한 데이터를 읽을 수 있어야 한다.
- 이번 장에서 살펴볼 요소
    - 데이터 부호화를 위한 다양한 형식
        - JSON, XML, 프로토콜 버퍼, Thrift, Avro
    - 예전 버전과 새로운 버전의 데이터와 코드가 공종하는 시스템 지원 방법
    - 여러 메시지 전달 시스템(REST, RPC, actor, message queue)에서 다양한 데이터 부호화 형식이 데이터 저장과 통신에 어떻게 사용되는지 살펴본다.

## 데이터 부호화 형식
- 프로그램은 최소 두가지 형태로 표현된 데이터 사용한다
    - 인메모리 표현
        - ex. 객체, 구조체, 목록, 배열 등
        - CPU에서 효율적으로 접근하고 조작할 수 있게 보통 포인터를 이용해 최적화됨
    - 바이트열
        - ex. JSON
        - 데이터를 파일에 쓰거나 네트워크를 통해 전송하기 위함
    - 두 가지 표현 사이에 일종의 전환 필요
        - 부호화(직렬화 또는 마샬링): 인메모리 표현 -> 바이트열
        - 복호화(파싱, 역직렬화, 언마샬링): 바이트열 -> 인메모리 표현
    
- 언어별 형식
    - 프로그래밍 언어에 부호화 기능 내장
        - 장점
            - 최소한의 추가 코드로 인메모리 객체 저장하고 복원 가능
        - 단점
            - 특정 프로그래밍 언어에 종속
            - 보안 취약점
                - 공격자가 임의의 클래스를 인스턴스화 할 수 있음. 
            - 상위, 하위 호환성의 문제
            - 효율성
                - ex. 자바 내장 직렬화는 성능이 좋지 않고 비대해지는 부호화로 유명
    
- JSON과 XML, 이진 변형
    - 표준화된 부호화 형식: JSON, XML, CSV
        - 텍스트 형식이라 어느 정도 사람이 읽을 수 있음
    - 문제점
        - 수(number)의 부호화 애매함
            - XML, CSV : 수와 숫자로 구성된 문자열 구분 불가능
            - JSON: 정수와 부동소수점 수를 구별하지 않고 정밀도를 지정하지 않는다.
                - 큰수 다룰 때 문제
                - 2^53 보다 큰 정수는 부동소수점 수에서는 정확하게 표현 불가
                - 트위터는 API에서 반환된 JSON에 수로 한번, 10진 문자열로 한번 트윗 ID를 포함시켜 이 문제 해결(트윗 ID로 64비트 숫자 사용)
        - 이진 문자열 지원하지 않음(JSON, XML)
            - Base64 사용해 텍스트로 부호화 하여 제한을 회피
            - 값이 Base64로 부호화 됐기 때문에 해석해야 한다는 사실을 스키마로 표현
            - 데이터 크기가 33% 증가한다. 
        - XML, JSON 스키마
            - XML, JSON 지원하는 스키마 언어 강력하지만 익히고 구현하기 난해함.
            - XML, JSON 스키마를 사용하지 않는 애플리케이션은 필요한 부호화/복호화 로직을 하드코딩해야 할 수 있음
        - CSV의 스키마 부재, 모호한 형식
            - 각 로우와 칼럼의 의미 정의는 애플리케이션이 해야함
            - 새로운 로우나 칼럼 추가 시 수동 변경 처리 필요
            - 이스케이핑 규칙을 공식적으로 규정 했지만 모든 파서가 규칙을 정확하게 구현하지 않는다. 
    - 위의 문제점에도 불구하고 데이터 교환 형식으로 사용하기 충분하다
        - 사람들이 사용에 동의만 한다면 얼마나 읽기 쉽고 효율적인 형식인지는 중요하지 않음
        - 무엇이든 다른 조직의 동의를 얻는 어려움은 대부분의 다른 문제보다 더 크기 때문
    
- 이진 부호화 
    - 조직 내에서만 사용하는 데이터라면 최소공통분모 부호화 형식(lowest-common-denominator encoding format) 사용 부담감이 덜하다.
    - 작은 데이터셋으론 부호화 형식 선택의 이득이 적지만 테라바이트 정도면 큰 영향 미친다
    - JSON은 XML 보다 덜 장황하지만 이진 형식과 비교하면 둘 다 훨씬 많은 공간 차지한다.
    - 이진 부호화 ex) 메시지팩, BSON, BJSON, ... 
    - 스키마를 지정하지 않기 때문에 부호화된 데이터 안에 모든 객체의 필드 이름을 포함해야 한다.
    
- 스리프트와 프로토콜 버퍼
    - 같은 원리를 기반으로 한 이진 부호화 라이브러리 (스리프트는 페이스북, 프로토콜 버퍼는 구글에서 개발)
    - 부호화할 데이터를 위한 스키마 필요
    - 스리프트의 이진 부호화 형식
        - 바이너리 프로토콜
            - 필드 이름이 없음
            - 부호화된 데이터는 숫자와 같은 필드 태그 사용
                - 필드 태그는 스키마에 명시되어 있음
        - 컴팩트 프로토콜 
            - 의미상으로는 바이너리 프로토콜과 같음. 
            - 필드 타입과 태그 숫자를 단일 바이트로 줄이고 가변 길이 정수를 사용해서 부호화 
    - 프로토콜 버퍼
        - 스리프트의 컴팩트 프로토콜과 매우 유사