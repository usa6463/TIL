# 부호화와 발전

- app은 필연적으로 시간이 지남에 따라 변함
- app 기능을 변경하려면 저장하는 데이터도 변경 필요
- 데이터 타입이나 스키마가 변경될 때 app 코드에 대한 변경이 종종 필요
- 하지만 대규모 app에서 코드 변경은 대개 즉시 반영할 수 없다.
    - 백엔드: rolling upgrade
    - 프론트엔드: 사용자에 좌우됨. 어떤 사용자는 한동안 업데이트를 설치하지 않을 수도 있다.
- 예전 버전의 코드와 새로운 코드, 이전의 데이터 타입과 새로운 데이터 타입이 시스템에 동시에 공종할 수 있다는 의미 
    - 양방향 호환성 필요
        - 하위 호환성
            - 새로운 코드는 예전 코드가 기록한 데이터를 읽을 수 있어야 한다.
        - 상위 호환성
            - 예전 코드는 새로운 코드가 기록한 데이터를 읽을 수 있어야 한다.
- 이번 장에서 살펴볼 요소
    - 데이터 부호화를 위한 다양한 형식
        - JSON, XML, 프로토콜 버퍼, Thrift, Avro
    - 예전 버전과 새로운 버전의 데이터와 코드가 공종하는 시스템 지원 방법
    - 여러 메시지 전달 시스템(REST, RPC, actor, message queue)에서 다양한 데이터 부호화 형식이 데이터 저장과 통신에 어떻게 사용되는지 살펴본다.

## 데이터 부호화 형식
- 프로그램은 최소 두가지 형태로 표현된 데이터 사용한다
    - 인메모리 표현
        - ex. 객체, 구조체, 목록, 배열 등
        - CPU에서 효율적으로 접근하고 조작할 수 있게 보통 포인터를 이용해 최적화됨
    - 바이트열
        - ex. JSON
        - 데이터를 파일에 쓰거나 네트워크를 통해 전송하기 위함
    - 두 가지 표현 사이에 일종의 전환 필요
        - 부호화(직렬화 또는 마샬링): 인메모리 표현 -> 바이트열
        - 복호화(파싱, 역직렬화, 언마샬링): 바이트열 -> 인메모리 표현
    
- 언어별 형식
    - 프로그래밍 언어에 부호화 기능 내장
        - 장점
            - 최소한의 추가 코드로 인메모리 객체 저장하고 복원 가능
        - 단점
            - 특정 프로그래밍 언어에 종속
            - 보안 취약점
                - 공격자가 임의의 클래스를 인스턴스화 할 수 있음. 
            - 상위, 하위 호환성의 문제
            - 효율성
                - ex. 자바 내장 직렬화는 성능이 좋지 않고 비대해지는 부호화로 유명
    
- JSON과 XML, 이진 변형
    - 표준화된 부호화 형식: JSON, XML, CSV
        - 텍스트 형식이라 어느 정도 사람이 읽을 수 있음
    - 문제점
        - 수(number)의 부호화 애매함
            - XML, CSV : 수와 숫자로 구성된 문자열 구분 불가능
            - JSON: 정수와 부동소수점 수를 구별하지 않고 정밀도를 지정하지 않는다.
                - 큰수 다룰 때 문제
                - 2^53 보다 큰 정수는 부동소수점 수에서는 정확하게 표현 불가
                - 트위터는 API에서 반환된 JSON에 수로 한번, 10진 문자열로 한번 트윗 ID를 포함시켜 이 문제 해결(트윗 ID로 64비트 숫자 사용)
        - 이진 문자열 지원하지 않음(JSON, XML)
            - Base64 사용해 텍스트로 부호화 하여 제한을 회피
            - 값이 Base64로 부호화 됐기 때문에 해석해야 한다는 사실을 스키마로 표현
            - 데이터 크기가 33% 증가한다. 
        - XML, JSON 스키마
            - XML, JSON 지원하는 스키마 언어 강력하지만 익히고 구현하기 난해함.
            - XML, JSON 스키마를 사용하지 않는 애플리케이션은 필요한 부호화/복호화 로직을 하드코딩해야 할 수 있음
        - CSV의 스키마 부재, 모호한 형식
            - 각 로우와 칼럼의 의미 정의는 애플리케이션이 해야함
            - 새로운 로우나 칼럼 추가 시 수동 변경 처리 필요
            - 이스케이핑 규칙을 공식적으로 규정 했지만 모든 파서가 규칙을 정확하게 구현하지 않는다. 
    - 위의 문제점에도 불구하고 데이터 교환 형식으로 사용하기 충분하다
        - 사람들이 사용에 동의만 한다면 얼마나 읽기 쉽고 효율적인 형식인지는 중요하지 않음
        - 무엇이든 다른 조직의 동의를 얻는 어려움은 대부분의 다른 문제보다 더 크기 때문
    
- 이진 부호화 
    - 조직 내에서만 사용하는 데이터라면 최소공통분모 부호화 형식(lowest-common-denominator encoding format) 사용 부담감이 덜하다.
    - 작은 데이터셋으론 부호화 형식 선택의 이득이 적지만 테라바이트 정도면 큰 영향 미친다
    - JSON은 XML 보다 덜 장황하지만 이진 형식과 비교하면 둘 다 훨씬 많은 공간 차지한다.
    - 이진 부호화 ex) 메시지팩, BSON, BJSON, ... 
    - 스키마를 지정하지 않기 때문에 부호화된 데이터 안에 모든 객체의 필드 이름을 포함해야 한다.
    
- 스리프트와 프로토콜 버퍼
    - 같은 원리를 기반으로 한 이진 부호화 라이브러리 (스리프트는 페이스북, 프로토콜 버퍼는 구글에서 개발)
    - 부호화할 데이터를 위한 스키마 필요
    - 스리프트의 이진 부호화 형식
        - 바이너리 프로토콜
            - 필드 이름이 없음
            - 부호화된 데이터는 숫자와 같은 필드 태그 사용
                - 필드 태그는 스키마에 명시되어 있음
        - 컴팩트 프로토콜 
            - 의미상으로는 바이너리 프로토콜과 같음. 
            - 필드 타입과 태그 숫자를 단일 바이트로 줄이고 가변 길이 정수를 사용해서 부호화 
    - 프로토콜 버퍼
        - 스리프트의 컴팩트 프로토콜과 매우 유사
    
    - 필드 태그와 스키마 발전
        - 스키마 발전: 스키마는 필연적으로 시간이 지남에 따라 변하고, 이를 스키마 발전이라고 함
        - 규칙
            - 스키마에서 필드 이름 변경 가능
                - 부호화된 데이터는 필드 이름 참조하지 않음
            - 필드 태그는 변경 불가능
                - 기존의 모든 부호화된 데이터 인식 불가능하게 할 수 있으므로
            - 새로운 필드 추가할 때 required로 설정 불가(optional이거나 default값 가져야함)
            - 필드 삭제
                - optional 필드만 삭제 가능
                - 같은 태그 번호는 절대 다시 사용 불가
          
        - 상위 호환
            - 예전 코드에서 새로운 코드로 기록한 데이터 읽는 경우
            - 예전 코드가 인식 불가능한 태그 번호 가진 필드가 있으면 데이터 타입 주석 참조하여 건너 뜀
          
        - 하위 호환
            - 신규 코드에서 예전 데이터 읽는 경우
            - 태그번호가 계속 같은 의미 가지므로 새로운 코드가 예전 데이터 항상 읽을 수 있음.
    
    - 데이터 타입과 스키마 발전
        - 필드의 데이터 타입을 변경할 순 있지만 값이 정확하지 않거나 잘릴 위험 존재함
        - 프로토콜 버퍼
            - 목록이나 배열 데이터 타입이 없고 repeated 표시자가 있음(required, optional과 함께 세번째 옵션)
            - repeated 필드의 부호화는 레코드에 단순히 동일한 필드 태그가 여러 번 나타남.
                - 이로 인해 단일값인 optional 필드를 다중 값인 repeated 필드로 변경해도 문제 없음
                - 이전 데이터를 읽은 새로운 코드(상위 호환성): 0이나 1개의 엘리먼트가 있는 목록으로 보게됨
                - 새로운 데이터를 읽는 예전 코드(하위 호환성): 목록의 마지막 엘리먼트만 보게 됨.
        - 스리프트
            - 전용 목록 데이터타입이 있음.
            - 목록 데이터 타입은 엘리먼트의 데이터 타입을 매개변수로 받음. 
            - protobuf와 다르게 단일 값에서 다중 값으로의 변경 허용하지 않음
            - 중첩된 목록 지원하는 장점 존재
    
- 아브로
    - 스리프트가 하둡의 사용 사례에 적합하지 않아 2009년 하둡의 하위 프로젝트로 시작됨.
    - 두 개의 스키마 언어 가짐
        - Avro IDL
            - 사람이 편집할 수 있음. 
        - JSON 기반 언어
            - 기계가 더 쉽게 읽을 수 있음. 
    - 바이트열
        - 필드나 데이터 타입을 식별하기 위한 정보가 없음. 
        - 스키마에 나타난 순서대로 필드를 살펴보고 스키마를 이용해 각 필드의 데이터 타입을 미리 파악해야 함
            - 데이터를 읽는 코드가 데이터를 기록한 코드와 정확히 같은 스키마 사용해야 올바르게 복호화 가능
    
    - 쓰기 스키마와 읽기 스키마
        - 쓰기 스키마: 부호화할 때 사용
        - 읽기 스키마: 복호화시 사용
        - 핵심 아이디어: 쓰기 스키마와 읽기 스키마가 동일하지 않아도 되며 호환 가능하면 된다
        - 쓰기 스키마와 읽기 스키마는 필드 순서가 달라도 문제 없음
            - 이름으로 필드를 일치
        - 데이터 읽는 코드
            - 읽기 스키마에는 없고 쓰기 스키마에 존재하는 필드 만나면 해당 필드 무시
            - 쓰기 스키마에는 없고 읽기 스키마에 존재하는 필드는 기본 값으로 채움
    
    - 스키마 발전 규칙
        - 상위 호환성: new 쓰기 스키마, old 읽기 스키마
        - 하위 호환성: new 읽기 스키마, old 쓰기 스키마
        - 규칙
            - 기본값이 있는 필드만 추가하거나 삭제 가능
            - 필드에 널을 허용하려면 유니온 타입 사용해야 함. 
                - ex) union { null, long, string } field;
                - 모든 널 가능 값을 갖기보다 장황하지만 널일 수 있는 것과 널일 수 없는 것이 명확해서 버그 막는데 도움
            - 필드의 데이터 타입 변경 가능
            - 필드 이름 변경 가능
                - 읽기 스키마는 필드 이름의 별칭 포함할 수 있음
                - 별칭에 예전 쓰기 스키마 필드 이름 매치 가능
                - 필드 이름 변경은 하위 호환성 있지만 상위 호환성 없음
                - 유니온 타입에 엘리먼트 추가 하는 것은 하위 호환성 있지만 상위 호환성 없음
    
    - 그러면 쓰기 스키마는 무엇인가?
        - 읽기가 특정 데이터를 부호화한 쓰기 스키마를 아는 방법
            - 많은 레코드가 있는 대용량 파일
                - 파일 시작 부분에 한 번만 쓰기 스키마 포함
                - 레코드들은 모두 동일한 스키마로 부호화 됨
            - 개별적으로 기록된 레코드를 가진 데이터베이스
                - 모든 부호화된 레코드의 시작 부분에 버전 번호를 포함하고 DB에서 스키마 버전 목록 유지
                - 읽기는 레코드 가져와 버전 번호 추출하고 DB에서 버전 번호에 해당 하는 쓰기 스키마 가져옴
                - DB에서 모든 레코드가 동일한 스키마 가진다고 가정할 수 없는 경우 사용
            - 네트워크 연결을 통해 레코드 보내기
                - 두 프로세스가 양방향 네트워크 연결 통해 통신할 때
                - 연결 설정에서 스키마 버전 합의 가능
                - 아브로 RPC 프로토콜이 이처럼 동작
    
    - 동적 생성 스키마
        - protobuf와 스리프트 대비 아브로 방식의 장점 한 가지: 스키마에 태그 번호가 없음
        - 이로인해 아브로는 동적 생성 스키마에 더 친숙함.
        - ex) RDB의 데이터를 파일로 덤프할 때
            - DB의 스키마가 변경되면 (ex. 칼럼 한개 추가하고, 다른 칼럼 하나 삭제한 경우)
                - 새로운 아브로 스키마 생성하고 데이터 내보냄
                - 이 과정에서 스키마 변경에 신경 쓸 필요가 없다. (스키마 변경이 실행될 때 마다 간단하게 수행 가능하다고 함.)
                - 새로운 데이터 파일을 읽는 사람은 레코드 필드가 변경된 사실을 알게 되지만 필드는 이름으로 식별되기 때문에 갱신된 쓰기 스키마는 여전히 이전 읽기 스키마와 매치 가능하다.
        - 이에 반해 스리프트나 프로토콜 버퍼를 위 용도와 같이 사요하면 필드 태그를 수동으로 할당해야 함.
            - 자동으로 할 수 있지만 스키마 생성자는 이전에 사용된 필드 태그가 할당되지 않게끔 조심해야 한다고함
    
    - 코드 생성과 동적 타입 언어
        - 스리프트와 프로토콜 버퍼는 코드 생성에 의존
            - 코드 생성: 프로그래밍 언어로 스키마를 구현한 코드 생성하는 것
            - 자바, C++ 같은 정적 타입 언어에서 유용
                - 복호화된 데이터를 위해 효율적인 인메모리 구조 사용 가능
                - IDE에서 타입 확인과 자동 완성 가능
        - 동적 타입
            - JS, ruby, python 같은 동적 타입 프로그래밍 언어에선 만족시킬 컴파일 시점의 타입 검사기가 없기 때문에 코드 생성이 중요하지 않다고 함. 
            - 아브로는 정적 타입 언어를 위한 코드 생성을 선택적으로 제공
            - 객체 컨테이너 파일이 있다면 아브로 라이브러리를 사용해 JSON 파일 보듯이 볼 수 있음.
                - 이 파일은 필요한 메타 데이터를 모두 포함하기 때문에 자기 기술적(self-describing)임.
    
    - 스키마의 장점
        - XML 스키마나 JSON 스키마보다 훨씬 간단하며 더 자세한 유효성 검사 규칙을 지원
            - ex) 이 필드의 문자열 값은 이 정규 표현식에 일치해야 한다.
        - 많은 데이터 시스템이 독자적으로 이진 부호화 구현하기도 함
            - ex) ODBC, JDBC API
        - 장점
            - 부호화된 데이터에서 필드 이름 생략 가능하므로 "이진 JSON" 변형보다 크기가 훨씬 작을 수 있다.
            - 스키마는 유용한 문서화 형식임. 복호화를 할 때 스키마가 필요하기 때문에 스키마가 최신 상태인지 확신 가능
            - 스키마 데이터베이스를 유지하면 스키마 변경이 적용되기 전에 상위 호환성과 하위 호환성을 확인 가능
            - 정적 타입 프로그래밍 언어는 스키마로부터 코드 생성 가능. 컴파일 시점에 타입 체크 가능
    
## 데이터플로 모드

- 데이터플로는 추상적인 개념으로서 하나의 프로세스에서 다른 프로세스로 데이터를 전달하는 것
- 데이터플로의 보편적인 방법
    - 데이터베이스를 통한 데이터플로
    - 서비스 호출을 통한
    - 비동기 메시지 전달을 통한


- 데이터베이스를 통한 데이터플로
    - 데이터베이스에 기록하는 프로세스는 데이터를 부호화하고 데이터베이스에서 읽는 프로세스는 데이터를 복호화 한다.
    - 하위 호환성 필요
        - 그렇지 않으면 이전에 기록한 내용을 미래의 자신이 복호화 불가능
    - 상위 호환성 필요
        - DB에는 여러 프로세스가 접근 하는 일이 흔하고, 순회식 업그레이드 등을 하면 동일한 app에서 일부 프로세스는 새로운 코드로 수행중이고, 다른 프로세스는 예전 코드로 수행될 수 있다.
        - DB 내 값이 새로운 버전 코드로 기록된 다음 현재 수행중인 예전 버전 코드로 그 값을 읽을 가능성 있음.
        - 문제점
            - 신규 버전에서 레코드 스키마에 필드 추가한 경우
                - 옛날 코드 입장에서 알지 못하는 unknown 필드를 DB에서 만나면 보존 하는게 바람직
    
    - 다양한 시점에 기록된 다양한 값
        - app의 새로운 버전을 배포할 때 몇 분 내에 예전 버전을 새로운 버전으로 대체할 수 있지만 DB 내용은 그렇지 않다.
        - 데이터가 코드보다 더 오래 산다(data outlives code)
        - 데이터를 새로운 스키마로 rewriting(migration) 하는 작업은 가능
            - 대용량 데이터셋 대상으로 값비싼 작업이라 가능하면 이런 상황 피함
        - RDB는 기존 데이터 다시 기록하지 않고 null을 기본 값으로 갖는 새로운 칼럼 추가 정도의 간단한 스키마 변경 허용
        - 예전 로우를 읽는 경우 디스크 상의 부호화된 데이터에서 누락된 임의 칼럼은 null로 채운다.
        - 따라서 스키마 발전은 기본 저장소가 여러가지 버전의 스키마로 부호화된 레코드를 포함해도 전체 DB가 단일 스키마로 부호화된 것 처럼 보이게 한다.
    
    - 보관 저장소
        - 백업 목적이나 DW에 적재하기 위해 데이터베이스의 스냅숏을 수시로 만든다. 
        - 소스 DB의 원본 부호화에 다양한 시점의 스키마 버전이 섞여 포함되어 있더라도
             - 데이터 덤프는 보통 최신 시크마를 사용해 부호화
        - 데이터 덤프는 한 번에 기록하고 이후 변하지 않으므로 아브로 객체 컨테이너 파일 같은 형식이 적합
            - 파케이: 분석 친화적인 칼럼 지향 형식
    
- 서비스를 통한 데이터플로: REST와 RPC
    - 가장 일반적인 방법으로 클라이언트와 서버의 두 역할로 배치
    - 서버가 공개한 API를 서비스라고 함.
    - 서비스지향 설계(SOA)와 마이크로서비스 설계(MSA)의 핵심 설계 목표
        - 서비스를 배포와 변경에 독립적으로 만들어 애플리케이션 변경과 유지보수를 더 쉽게 할 수 있게 만드는 것
    - 예전 버전과 새로운 버전의 서버, 클라이언트가 동시에 실행되기를 기대한다.
    - 따라서 서버와 클라이언트가 사용하는 데이터 부호화는 서비스 API의 버전 간 호환이 가능해야 함.
    
    - 웹 서비스
        - 서비스와 통신하기 위한 기본 프로토콜로 HTTP를 사용할 때 이를 웹서비스라고 함.
        - REST
            - HTTP의 원칙을 토대로 한 설계 철학
            - 간단한 데이터 타입을 강조하며 URL을 사용해 리소스를 식별하고 캐시 제어, 인증, 콘텐츠 유형 협상에 HTTP기능 사용
            - 조직간 서비스 통합과 관련하여 SOAP에 비해 인기를 얻고 있음.
            - 스웨거(Swagger)로 알려진 OpenAPI 같은 정의 형식을 사용해 제품 문서 기술에 사용
        - SOAP
            - 네트워크 API 요청을 위한 XML 기반 프로토콜
            - HTTP 상에서 가장 일반적으로 사용되지만 HTTP와 독립적이며 대부분의 HTTP 기능 사용하지 않음
            - 다양한 기능을 추가한 광범위하고 복잡한 여러 관련 표준(WS-*) 제공
            - API는 WSDL(Web Services Description Language)라 부르는 XML 기반 언어 사용해 기술
            - WSDL은 클라이언트가 로컬 클래스와 메소드 호출을 사용해 원격 서비스에 접근하는 코드 생성이 가능
            - WSDL은 사람이 읽을 수 있게 설계하지 않았고 수동으로 구성하기 복잡하므로 도구 지원과 IDE에 크게 의존
    
    - 원격 프로시저 호출(RPC)의 문제
        - RPC 모델은 원격 네트워크 서비스 요청을 같은 프로세스 안에서 특정 프로그래밍 언어의 함수나 메서드를 호출하는 것과 동일하게 사용 가능하게 한다.
        - RPC 접근 방식은 근본적으로 결함이 있다.
            - 로컬 함수 호출과 달리 네트워크 요청은 예측이 어렵다
            - 네트워크 요청은 타임아웃으로 결과없이 반환될 수 있다.
                - 원격 서비스로부터 응답을 받지 못하면 요청을 제대로 보냈는지 아닌지를 알 수 있는 방법이 없다.
            - 요청이 실제로는 처리되고 응답만 유실 가능
                - 멱등성을 적용하지 않으면 재시도시 작업이 여러번 수행되는 원인이 된다.
            - 네트워크 요청은 함수 호출보다 느리고 지연시간이 매우 다양하다
                - 네트워크가 혼자하거나 원격 서비스에 과부하 걸리면 같은 작업 수행시에도 수초가 걸릴 수 있다.
            - 모든 매개변수는 네트워크를 통해 전송할 수 있게끔 바이트열로 부호화해야 한다.
                - 매개변수가 숫자나 문자열 같은 원시형이면 괜찮지만 큰 객체라면 문제가 될 수 있다.
            - 클라이언트와 서비스가 다른 프로그래밍 언어로 구현될 수 있다.
                - RPC 프레임워크는 다른 언어로 데이터타입을 변환해야 한다
                - 모든 언어가 같은 타입을 가지진 않으므로 깔끔하지 않은 모습이 될 수 있다.
    - RPC의 현재 방향
        - 이번 장에서 언급한 모든 부호화 위에는 다양한 RPC 프레임워크가 개발됐다
        - ex) gRPC는 프로토콜 버퍼를 이용한 RPC 구현
        - 퓨처(future, promise)
            - 실패할지도 모를 비동기 작업을 캡슐화 하기 위해 사용
            - 병렬로 여러 서비스에 요청을 보내야 하는 상황을 간소화하고 요청 결과를 취합 
        - service discovery
            - 클라이언트가 특정 서비스를 찾을 수 있는 IP 주소와 포트 번호를 제공
        - REST는 JSON 같은 부류의 프로토콜 쓰지만 RPC는 이진 부호화 형식을 사용해서 더 우수한 성능을 제공하는 듯
        - RESTful API의 장점
            - 실험과 디버깅에 적합
            - 모든 주요 프로그래밍 언어와 플랫폼이 지원
            - 사용 가능한 다양한 도구 생태계 
        - REST는 공개 API의 주요한 방식, RPC는 같은 데이터센터 내 같은 조직이 소유한 서비스 간 요청에 적합해 보임.
    
    - 데이터 부호화와 RPC 발전
        - 발전성이 있으려면 RPC 클라이언트와 서버를 독립적으로 변경하고 배포할 수 있어야 함
        - 모든 서버를 먼저 갱신하고 나서 모든 클라이언트를 갱신해도 문제가 없음
            - 요청은 하위 호환성만 필요하고 응답은 상위 호환성만 필요
        - 호환성을 깨는 변경이 필요하면 서비스 제공자는 여러 버전의 API 함께 유지
            - API 버전 관리가 반드시 어떤 방식으로 동작해야 한다는 합의는 없다.
            - RESTful API는 URL이나 HTTP Accept 헤더에 버전 번호 사용하는 방식이 일반적
            - API 키를 사용하는 서비스는 요청 API 버전을 서버에 저장한 뒤 버전 선택을 별도 관리 인터페이스 통해 갱신할 수 있게 할 수 있음
    
- 메시지 전달 데이터 플로
    - REST, RPC 통한 전달: 하나의 프로세스가 네트워크를 통해 다른 프로세스로 요청을 전송하고 가능한 빠른 응답 기대하는 방식
    - 데이터베이스 통한 전달: 부호화된 데이터를 기록하고 다른 프로세스가 언젠가 그 데이터를 다시 읽는 방식
    - 비동기 메시지 전달 시스템
        - 낮은 지연시간으로 다른 프로세스에 전달한다는 점에서 RPC와 비슷
        - 메시지를 직접 네트워크 연결로 전송하지 않고 메시지 브로커(또는 메시지큐)나 메시지 지향 미들웨어라는 중간 단계 거쳐 전송한다는 점에 데이터베이스와 유사
        - 장점
            - 시스템 안전성 향상
                - 수신자가 사용불가능하거나 과부하 상태라면 메시지 브로커가 버퍼처럼 동작
            - 메시지 유실 방지
                - 죽었던 프로세스에 다시 메시지 전달 가능
            - 송신자가 수신자의 IP 주소나 포트 알 필요 없음
            - 하나의 메시지를 여러 수신자로 전송 가능
            - 논리적으로 송신사는 수신자와 분리됨
                - 송신 프로세스는 대개 메시지에 대한 응답 기대하지 않음. 
                - 이런게 비동기 통신 패턴임
                - 단순히 메시지를 보낸 뒤 잊는다. 
    
    - 메시지 브로커
        - 최근에는 오픈소스 구현이 대중화됨. (아프치 카프카 등)
        - 프로세스 하나가 메시지를 이름이 지정된 큐나 토픽으로 전송하고 브로커는 해당 큐나 토픽 하나 이상의 소비자 또는 구독자에게 메시지 전달
        - 동일한 토픽에 여러 생산자와 소비자가 있을 수 있다.
        - 토픽은 단방향 데이터플로만 제공 
            - 하지만 소비자 스스로가 
                - 메시지를 다른 토픽으로 게시 가능
                - 원본 메시지의 송신자가 소비하는 응답 큐로 게시할 수 있다.
        - 메시지 브로커는 특정 데이터 모델 강요하지 않음
            - 메시지는 일부 메타데이터를 가진 바이트열이므로 모든 부호화 형식 사용 가능 
    
    - 분산 액터 프레임워크
        - 액터모델
            - 단일 프로세스 안에서 동시성을 위한 프로그래밍 모델
            - 스레드(경쟁 조건, 잠금, 교착상태 와 연관된 문제들)를 직접 처리하는 대신 로직이 액터에 캡슐화
            - 각 액터는 하나의 클라이언트나 엔티티를 나타냄
            - 액터는 로컬 상태를 가질 수 있고 비동기 메시지의 송수신으로 다른 액터와 통신
            - 액터는 메시지 전달 보장하지 않음
            - 각 액터 프로세스는 한 번에 하나의 메시지만 처리하기 떄문에 스레드에 대한 걱정 필요 없고, 각 액터는 프레임워크와 독립적으로 실행 가능
        - 분산 액터 프레임워크
            - 메시지 브로커와 액터 프로그래밍 모델을 단일 프레임워크에 통합
            - 순회식 업그레이드 수행 원하면 상위 호환성에 주의
            - 종류: 아카(Akka), 올리언스, 얼랭
    
## 정리
- 순회식 업그레이드는 발전성에 큰 도움이 됨
    - 순회식 업그레이드나 여러 다른 이유로 다양한 노드에서 다른 버전의 애플리케이션 코드가 수행됨
    - 따라서 시스템을 흐르는 모든 데이터는 하위 호환성과 상위 호환성을 제공하는 방식으로 부호화 해야함.
- 데이터 부호화 형식과 호환성 속성
    - 프로그래밍 언어 특화 부호화
        - 단일 프로그래밍 언어로 제한
        - 상, 하위 호환성 제공하지 못하는 경우 종종 있음
    - 텍스트 형식(JSON, CSV, XML)
        - 호환성은 이 형식들을 사용하는 방법에 달려 있음
        - 선택적 스키마 언어가 있으면 때로는 유용하기도, 방해되기도 한다
        - 데이터 타입에 대해 다소 모호한 부분 존재. 숫자나 이진 문자열 같은 항목 주의 필요
    - 이진 스키마 기반(스리프트, 프로토콜 버퍼, 아브로)
        - 짧은 길이로 부호화
        - 명확하게 정의된 상위, 하위 호환성 맥락에서 효율적인 부호화 지원
        - 정적 타입 언어에서 문서와 코드 생성에 유용
        - 사람이 읽기 위해서 복호화 해야 하는 단점 
    
- 데이터플로 모드
    - 데이터 베이스
    - REST API, RPC
    - 비동기 메시지 전달(메시지 브로커나 액터 사용)