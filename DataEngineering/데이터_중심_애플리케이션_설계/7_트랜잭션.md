# 트랜잭션
- `트랜잭션 없이 코딩하는 것보다 트랜잭션을 과용해서 병목지점이 생기는 성능 문제를 애플리케이션 프로그래머가 처리하게 하는 게 낫다고 생각한다`
  
- 트랜잭션: 전체가 성공(커밋) 하거나 실패(abort, rollback)
  
- 현실에서의 문제
    - 잠재적인 오류 시나리오(일련의 처리 진행중 장애 발생하여 끊김)
      - DB에 write 하는 도중 DB가 죽는 경우 
    - 동시성 문제
      - 여러 클라이언트가 동시에 DB에 write 해서 다른 클라이언트가 쓴 내용을 덮는 경우
    
- 위의 현실 문제를 해결하기 위해 트랜잭션이라는 개념을 사용
    - 무조건 적용하는게 좋은건 아님.
    - 트랜잭션이 필요하지 않은 상황에선 트랜잭션 보장 완화하거나 아예 쓰지 않는 게 이득
    - 예를들어, 성능을 향상 시키거나 가용성을 높일 수 있다. 
    
- 안전성 보장(safety guarantee)
    - 트랜잭션을 사용함으로써 애플리케이션에서 어느 정도의 잠재적인 오류 시나리오와 동시성 문제를 무시할 수 있다.
    
- ACID
    - 트랜잭션이 제공하는 안전성 보장을 의미하는 약어
    - DB에서 내결함성 메커니즘을 나타내는 정확한 용어를 확립하기 위해 테오 하더, 안데르아스 로이터가 만듦.
    
- 원자성(atomicity)
    - 일련의 동작 중 중지된다면 실행하기 이전으로 돌리는 특징     
    - 어보트 능력(abortability)가 더 적합한 단어일 수 있다.
    - 트랜잭션이 어보트 됐다면 애플리케이션에서 이 트랜잭션이 어떤 것도 변경하지 않았음을 알 수 있으므로 안전하게 재시도할 수 있다.

- 일관성(consistency)
    - 항상 진실이어야 하는, 데이터에 관한 어떤 선언(불변식, invariant)이 있다는 것.
        - ex. 회계 시스템에서 모든 계좌에 걸친 대변과 차변은 항상 맞아떨어져야 한다. 
    - DB가 보장할 수 있는 특징이 아님. 애플리케이션에서 올바르게 정의해야 함.(ACID 중 유일하게 애플리케이션 속성)

- 격리성(isolation)
  - 동시에 실행되는 트랜잭션은 서로 격리된다. 트랜잭션은 다른 트랜잭션을 방해할 수 없다. 
  - 동시성 문제(race condition) 해결 -> 격리수준

- 지속성(durability)
  - 트랜잭션이 성공적으로 커밋됐다면 하드웨어 결함이 발생하거나 데이터베이스가 죽더라도 트랜잭션에서 기록한 모든 데이터는 손실되지 않는다는 보장
  - 지속성을 보장하려면 데이터베이스는 트랜잭션이 성공적으로 커시됐다고 보고하기전에 쓰기나 복제가 완료될 때까지 기다려야 한다.
  - 현실에서 절대적인 보장은 없다. 위험을 줄이려는 기법이 여러 있을 뿐(복제, 디스크 쓰기, 백업 등)
  - 항상 이론적인 "보장"은 약간 에누리해서 듣는게 현명하다
  
- 다중 객체 연산
  - 여러개의 객체를 변경해야할 경우
    - ex) 
      - 이메일 애플리케이션. 새 메시지가 올 때마다 읽지 않은 메시지 개수 증가도 해야하고, 읽지 않은 메시지를 별개의 필드에 저장도 할 수 있다. 
      - 인덱스가 있는 테이블에 데이터를 삽입하면, 테이블도 변경이 발생하고, 인덱스에도 변경이 발생한다.
  - 원자성, 격리성이 필요
  - 트랜잭션은 보통 다중 객체에 대한 다중 연산을 하나의 실행 단위로 묶는 메커니즘으로 이해된다.
  - 많은 분산 데이터스토어는 다중 객체 트랜잭션 지원을 포기했다. 다중 객체 트랜잭션은 여러 파티션에 걸쳐서 구현하기 어렵고, 매우 높은 가용성과 성능이 필요한 곳에서는 방해가 되는 시나리오도 있기 때문.
- 단일 객체 연산
  - 원자성과 격리성은 여기에도 적용된다
  - 원자성: 장애 복구용 로그를 써서 구현 가능
  - 격리성: 각 객체에 잠금을 사용해 구현

- 오류와 어보트 처리
  - 트랜잭션의 핵심기능: 오류가 생기면 어보트 되고 안전하게 재시도할 수 있게 한다.
  - 모든 시스템이 이 철학은 따르지 않음. 
    - best effort 원칙: 데이터베이스는 가능한 모든 것을 할 것이며, 그 때문에 오류가 발생 하면 이미 한 일은 취소 하지 않는다.
    - 특히 리더 없는 복제를 사용하는 데이터 스토어에서 이러함

- 완화된 격리 수준
  - 동시성 문제는 트랜잭션이 다른 트랜잭션에서 동시에 변경한 데이터를 읽거나 두 트랜잭션이 동시에 같은 데이터를 변경하려고 할 때 발생
  - 동시성 버그는 타이밍에 운이 없을 때만 촉발되므로 테스트로 발견하기 어렵다
  - 데이터베이스는 트랜잭션 격리를 통해 동시성 문제를 감추려고 했음.
  - 특히 직렬성 격리는 여러 트랜잭션들이 직렬적으로 실행되는 것과 동일한 결과가 나오도록 보장. 대신 성능 비용이 있고, 많은 데이터베이스들은 그 비용을 지불하려 하지 않는다. 
  - 특정 동시성 이슈로부턴 보호해주지만 모든 이슈로부터 보호해주진 않는 완화된 격리 수준을 사용하는 시스템이 흔하다. 

- 격리 수준
  - 커밋 후 읽기
    - 가장 기본적인 수준의 트랜잭션 격리. 아래 내용을 보장한다. 
      - 더티 읽기 방지(데이터베이스에서 읽을 때 커밋된 데이터만 보게 된다)
        - 더티 읽기 방지가 안되면 한 트랜잭션이 여러 객체를 수정할 때, 다른 트랜잭션 입장에선 어느 객체는 수정된 내용을 보고, 다른 객체는 수정되지 않은 내용을 보는것을 방지
          - ex) 이메일 발송. 새 이메일 내용이 추가되고, 안읽은 메일 갯수도 +1 되어야 한다. 그런데 이 트랜잭션 와중에 다른 트랜잭션이 읽기를 시도하면 새 이메일 내용은 보이는데 안읽은 메일 갯수는 그대로인 상황을 마주할 수도 있다.
        - 트랜잭션이 어보트 되는 경우, 더티 읽기 방지가 안되면 롤백될 데이터를 다른 트랜잭션에서 읽을 수도 있다. 
      - 더티 쓰기 방지(데이터베이스에서 쓸 때 커밋된 데이터만 덮어쓰게 된다)
        - 일반적으로 나중에 쓴 내용이 먼저 쓴 내용을 덮어쓴다고 가정
        - 더티 쓰기: 먼저 쓴 내용이 커밋되지 않은 트랜잭션에서 쓴 것이고, 나중에 실행된 쓰기 작업이 커밋되지 않은 값을 덮어써버리는 문제
        - ![img.png](image/7-5.png)
        - 그런데 이런 카운터 문제는 해결하지 못한다. 이미 User1이 커밋한 내용에 대해 쓰기를 하는 것이기 때문
          - ![img.png](image/7-1.png) 
    - 구현
      - 오라클 11g, postgresql, SQL서버 2012, MemSQL 등 여러 DB에서 기본 설정
      - 더티 쓰기
        - 로우 수준 잠금을 통한 방법
          - 트랜잭션에서 특정 객체를 변경하고 싶다면 잠금을 우선 획득
          - 트랜잭션이 커밋되거나 어보트될 때 까지 잠금을 보유해야 함
          - 오직 한 트랜잭션만 어떤 주어진 객체에 대한 잠금 보유 가능
          - 뮤텍스 같은 느낌이네
      - 더티 읽기
        - 뮤텍스 방법을 쓸수도 있지만, 읽기만 실행하는 여러 트랜잭션들이 오래 실행되는 쓰기 트랜잭션 하나가 완료될 때 까지 기다려야할 수 있어서 현실에선 운용성이 나쁘다
        - 대부분의 DB는 아래 방법 사용
          - DB는 과거에 커밋된 값과 현재 쓰기 잠금을 갖고 있는 트랜잭션에서 쓴 새로운 값을 모두 기억
          - 해당 트랜잭션이 실행중인 동안은 그 객체를 읽는 다른 트랜잭션들은 과거의 값을 읽게 됨.
          - ![img.png](image/7-4.png)
  - 스냅숏 격리와 반복 읽기
    - 커밋 후 읽기를 사용해도 여전히 동시성 버그가 있을 수 있다. 아래는 그 예
      - ![img.png](image/7-6.png)
      - 잠시동안 엘리스 입장에선 100 달러가 사라진 것 처럼 보일 수 있다. 일관성(정합성) 깨짐
      - 이런 현상을 비반복 읽기(nonrepeatable read), 읽기 스큐(read skew)라고 한다. 
      - 몇초 후 다시 새로고침하면 일관성있어 보임
    - 일시적인 비일관성을 감내할 수 없는 경우
      - 백업: 백업 프로세스 중에도 DB에 계속 쓰기가 실행됨. 그때 읽기 스큐 상황이 있다면 이런 비일관성이 영속적이게 된다 
      - 분석 질의와 무결성 확인: 데이터베이스의 큰 부분을 스캔하는 질의를 실행할 때(즉 오래 걸리는). 다른 시점의 데이터베이스 일부를 보면 비일관성 발생
    - 스냅숏 격리: 각 트랜잭션은 데이터베이스의 일관된 스냅숏으로부터 읽는다
    - 이것도 널리 쓰이는 기능임. postgresql, InnoDB 저장소 엔진을 쓰는 MySQL, Oracle 등 사용
    - 구현
      - 쓰기: 커밋 후 읽기 처럼 쓰기 잠금을 사용
      - 핵심원리: 읽는 쪽에서 쓰는 쪽을 차단하지 않고, 쓰는 쪽에서 읽는 쪽을 차단하지 않는다
      - 읽기
        - 데이터베이스는 객체마다 커밋된 버전 여러개를 유지한다 -> 다중 버전 동시성 제어 (MVCC, multi-version concurrency control)
        - 커밋후 읽기가 객체마다 두개씩만 유지하는 것과 다름
        - ![img.png](image/7-7.png)
    - 일관된 스냅숏을 보는 가시성 규칙
      - 각 트랜잭션을 시작할 때 그 시점에 진행중인 트랜잭션 목록을 만들고, 이 트랜잭션이 쓴 데이터는 모두 무시한다
      - 어보트된 트랜잭션이 쓴 데이터는 무시한다
      - 트랜잭션 ID가 더 큰 트랜잭션이 쓴 데이터는 커밋 여부에 관계없이 무시
      - 그 밖의 모든 데이터는 애플리케이션의 질의로 볼 수 있음.
    - 색인과 스냅숏 격리
      - 단순한 방법: 색인이 객체의 모든 버전을 가리키게 하고, 현재 트랜잭션에서 볼 수 없는 버전을 걸러내는 것
      - 몇몇 데이터베이스의 세부 구현이 소개 되어 있는데, 필기까지 할 필요는 없을듯
    - 반복 읽기와 혼란스러운 이름
      - 스냅숏 격리 == 반복 읽기 == 직렬성
      - 스냅숏 격리를 구현한 많은 데이터베이스에서 서로 다른 이름으로 이를 부름. 오라클에선 직렬성, mySQL에선 반복 읽기
  - 갱신 손실 방지
    - 갱신 손실(lost update): 쓰기 트랜잭션 사이에 발생할 수 있는 이슈 유형. 스냅숏 격리나 커밋후 읽기로 해결 안됨.
      - DB에서 값을 읽고 변경, 이후 변경된 값을 다시 쓰는 작업(Read-modify-write 주기)이 동시에 여러곳에서 일어나는 경우 발생
      - 예
        - 위키에서 두명의 사용자가 동시에 같은 페이지 편집
        - 카운터를 증가시키거나 계좌 잔고 갱신
    - 해결책
      - 원자적 쓰기연산
        - read-modify-write 주기를 없애줌. 
        - 예) RDB UPDATE 문
        - 대부분의 RDB에서 동시성 안전(concurrency-safe)하다
        - 보통 객체를 읽을 때 그 객체에 독점적인(execlusive) 잠금을 획득해서 구현
          - 커서 안정성(cursor stability) 라고도 한다.
          - 근데 이거 스냅숏 격리나, 커밋후 읽기에서 봤던 방법이랑 그냥 똑같지 않나?
            - 걔들은 쓰기만 막는거지만 여긴 읽지도 못하게 한다고 되어 있음.
          - 다른 선택지는 그냥 모든 원자적 연산을 단일 스레드에서 실행하도록 하는것 (병렬 처리가 아니게 된다)
        - ORM 프레임워크 쓰면 DB가 제공하는 원자적 연산 대신 read-modify-write 주기 실행하는 코드 작성하기 쉽다
          - 자신이 뭘 하고 있는지 알고 있으면 문제가 아니지만 잠재적으로는 테스트로 발견하기 어려운 버그 원인이 될 수 있다.
      - 명시적인 잠금
        - 애플리케이션에서 갱신할 객체를 명시적으로 잠그는 것
        - 애플리케이션이 read-modify-write 주기를 수행하고 다른 트랜잭션이 동시에 같은 객체를 읽으려고 하면, 첫번째 rmw 주기가 완료될 때까지 기다리도록 강제된다.
      - 갱신 손실 자동 감지
        - rmw 주기 병렬 실행을 허용하고 트랜잭션 관리자가(보통 DB) 갱신 손실을 발견하면 트랜잭션을 어보트 시키고 rmw 주기를 재시도하도록 갖에하는 방법
        - 스냅숏 격리와 결합해 효율적으로 수행 가능
        - 실제로 Postgresql의 반복 읽기, 오라클의 직렬성, SQL 서버의 스냅숏 격리 수준은 갱신 손실 발생하면 자동 발견해서 문제가 되는 트랜잭션을 어보트시킨다.
        - 그러나 MySQL, InnoDB는 반복읽기에서 갱신 손실 감지하지 않는다. 
      - Compare-and-set
        - 값을 마지막으로 읽은 후로부터 변경되지 않았을 때만 갱신을 허용
        - 이전에 읽은 값과 다르면 갱신은 반영되지 않고 rmw 주기 재시도
        - 예) 두 명의 사용자가 동시에 같은 위키 페이지를 갱신하지 못하도록 할 때
          - UPDATE wiki_pages SET content='new content' WHERE id=1234 AND content='old content'
      - 충돌 해소와 복제
        - 복제가 적용된 DB에선, 여러 노드에 있는 복사본 데이터가 다른 노드들에게서 동시에 변경 될 수 있으므로 갱신 손실 방지를 위한 추가 단계가 필요
        - 방법
          - 쓰기가 동시에 실행될 때 한 값에 대해 여러개의 충돌된 버전(형제(sibling))을 생성하는 것을 허용. 사후에 애플리케이션 코드나 특별한 데이터 구조를 사용해 충돌을 해소하고 이 버전들을 병합하는 것.
          - 원자적 연산: 특히 교환 법칙이 성립하는 연산이라면 잘 동작.
            - 교환법칙 성립 케이스: 다른 복제본에 다른 순서로 연산을 적용해도 같은 결과가 나온는 경우
          - 잠금과 compare-and-set은 최신 복사본이 하나만 있다고 가정하는 경우라 잘 동작하지 않음
        - 최종 쓰기 승리(last write wins, LWW) 충돌해소 방법은 갱신 손실 발생하기 쉽다.
          - 많은 복제 DB는 LWW가 기본 설정
  - 쓰기 스큐와 팬텀
    - 쓰기 스큐 예시
      - 의사의 호출 대기 상황 (최소 1명은 대기해야하는데, 2명 이상 대기중이면 한명은 아플경우 대기에서 빠질 수 있음.)
      - 회의실 예약 시스템(동시에 같은 회의실을 중복 예약할 수 없게 하고 싶음)
    - ![img.png](image/7-8.png)
    - 두 트랜잭션이 두 개의 다른 객체를 갱신하므로(엘리스 row, 밥 row) 더티 쓰기도 갱신 손실도 아니다.
    - 쓰기 스큐 해법
      - 특정 데이터베이스는 제약 조건 설정을 통해 해결 가능(트리거, 구체화 뷰 등)
      - 트랜잭션이 의존하는 로우를 명시적으로 잠그는 것이 차선책. 
    - 팬텀: 어떤 트랜잭션이 실행한 쓰기가 다른 트랜잭션의 검색 질의 결과를 바꾸는 효과
      - 패턴
        - SELECT 질의가 어떤 검색 조건에 부합하는 로우를 검색하여 요구사항을 만족하는지 확인
        - 질의 결과에 따라 애플리케이션 코드는 어떻게 진행할지 결정
        - 애플리케이션이 계속 처리하기로 했다면 데이터베이스에 쓰고 트랜잭션을 커밋(이 쓰기의 효과로 2단계를 결정한 전제 조건이 바뀐다)
    - 충돌 구체화
      - 팬텀의 문제가 잠글 수 있는 객체가 없는 것이라, 인위적으로 데이터베이스에 잠금 객체를 추가하는 방법
      - 예) 회의실 예약의 경우, 시간 슬롯과 회의실에 대한 테이블을 만드는 것
        - 이제 예약을 하는 트랜잭션은 테이블에서 원하는 회의실과 시간 범위에 해당하는 로우를 잠글 수 있다.(SELECT FOR UPDATEE)
      - 충돌을 구체화하는 방법은 알아내기 어렵고, 오류가 발생하기 쉽다. 그리고 동시성 제어 메커니즘이 애플리케이션 데이터모델로 새어 나오는 것도 보기 좋지 않다. 
      - 다른 대안이 불가능할 때 최후의 수단으로 고려해야 한다.
  - 직렬성
    - 격리 수준의 단점(완화된 격리 수준이 처음 소개된 1970년대부터 있던 문제)
      - 격리수준은 이해하기 어렵고, DB마다 그 구현에 일관성이 없다
      - 애플리케이션 코드를 보고 특정한 격리 수준에서 해당 코드 실행이 안전한지 알기 어렵다
      - 경쟁 조건을 감지 하는데 도움이 되는 좋은 도구가 없다. 
    - 이런 상황에서 연구자들의 대답도 죽 간단했다. 직렬성 격리를 사용하라
    - 직렬성 격리
      - 보통 가장 강력한 격리 수준이라 여겨짐
      - 여러 트랜잭션이 실행되어도, 최종 결과는 항상 한번에 하나씩 직렬로 실행될 때와 같도록 보장함
      - 즉 데이터베이스에서 발생할 수 있는 모든 경쟁조건을 막아준다.
    - 오늘날 직렬성을 제공하는 데이터베이스는 대부분 아래 세 가지 기법 중 하나를 사용한다.
      - 말 그대로 트랜잭션을 순차적으로 실행하기
      - 2단계 잠금(2PL)
      - 직렬성 스냅숏 격리 같은 낙관적 동시성 제어(optimistic concurrency control)
      