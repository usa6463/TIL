# 트랜잭션
- `트랜잭션 없이 코딩하는 것보다 트랜잭션을 과용해서 병목지점이 생기는 성능 문제를 애플리케이션 프로그래머가 처리하게 하는 게 낫다고 생각한다`
  
- 트랜잭션: 전체가 성공(커밋) 하거나 실패(abort, rollback)
  
- 현실에서의 문제
    - 잠재적인 오류 시나리오(일련의 처리 진행중 장애 발생하여 끊김)
      - DB에 write 하는 도중 DB가 죽는 경우 
    - 동시성 문제
      - 여러 클라이언트가 동시에 DB에 write 해서 다른 클라이언트가 쓴 내용을 덮는 경우
    
- 위의 현실 문제를 해결하기 위해 트랜잭션이라는 개념을 사용
    - 무조건 적용하는게 좋은건 아님.
    - 트랜잭션이 필요하지 않은 상황에선 트랜잭션 보장 완화하거나 아예 쓰지 않는 게 이득
    - 예를들어, 성능을 향상 시키거나 가용성을 높일 수 있다. 
    
- 안전성 보장(safety guarantee)
    - 트랜잭션을 사용함으로써 애플리케이션에서 어느 정도의 잠재적인 오류 시나리오와 동시성 문제를 무시할 수 있다.
    
- ACID
    - 트랜잭션이 제공하는 안전성 보장을 의미하는 약어
    - DB에서 내결함성 메커니즘을 나타내는 정확한 용어를 확립하기 위해 테오 하더, 안데르아스 로이터가 만듦.
    
- 원자성(atomicity)
    - 일련의 동작 중 중지된다면 실행하기 이전으로 돌리는 특징     
    - 어보트 능력(abortability)가 더 적합한 단어일 수 있다.
    - 트랜잭션이 어보트 됐다면 애플리케이션에서 이 트랜잭션이 어떤 것도 변경하지 않았음을 알 수 있으므로 안전하게 재시도할 수 있다.

- 일관성(consistency)
    - 항상 진실이어야 하는, 데이터에 관한 어떤 선언(불변식, invariant)이 있다는 것.
        - ex. 회계 시스템에서 모든 계좌에 걸친 대변과 차변은 항상 맞아떨어져야 한다. 
    - DB가 보장할 수 있는 특징이 아님. 애플리케이션에서 올바르게 정의해야 함.(ACID 중 유일하게 애플리케이션 속성)

- 격리성(isolation)
  - 동시에 실행되는 트랜잭션은 서로 격리된다. 트랜잭션은 다른 트랜잭션을 방해할 수 없다. 
  - 동시성 문제(race condition) 해결 -> 격리수준

- 지속성(durability)
  - 트랜잭션이 성공적으로 커밋됐다면 하드웨어 결함이 발생하거나 데이터베이스가 죽더라도 트랜잭션에서 기록한 모든 데이터는 손실되지 않는다는 보장
  - 지속성을 보장하려면 데이터베이스는 트랜잭션이 성공적으로 커시됐다고 보고하기전에 쓰기나 복제가 완료될 때까지 기다려야 한다.
  - 현실에서 절대적인 보장은 없다. 위험을 줄이려는 기법이 여러 있을 뿐(복제, 디스크 쓰기, 백업 등)
  - 항상 이론적인 "보장"은 약간 에누리해서 듣는게 현명하다
  
- 다중 객체 연산
  - 여러개의 객체를 변경해야할 경우
    - ex) 이메일 애플리케이션. 새 메시지가 올 때마다 읽지 않은 메시지 개수 증가도 해야하고, 읽지 않은 메시지를 별개의 필드에 저장도 할 수 있다. 
