# 저장소와 검색

- 특정 작업부하(workload) 유형에서 좋은 성능을 내게끔 저장소 엔진을 조정하려면 저장소 엔진이 내부에서 수행된느 작업에 대해 대략적인 개념을 이해할 필요가 있다.
- 트랜잭션 작업부하게 맞춰 최적화된 저장소 엔진과, 분석을 위해 최적화된 엔진 간에는 큰 차이가 있음
- 이번 장에서는 관계형 DB, NoSQL DB에서 사용하는 저장소 엔진에 대해 설명
- 그리고 log structured, page-oriented 계열 저장소 엔진 검토

## 데이터베이스를 강력하게 만드는 데이터 구조
- 많은 데이터베이스는 내부적으로 추가 전용(append-only) 데이터 파일인 로그를 사용
    - 이 책에서 로그는 연속된 추가 전용 레코드를 의미
- 키-값 저장소에서 색인이 없으면 매번 키를 찾을 때 마다 전체 데이터베이스 파일을 처음부터 끝까지 스캔해야 한다
    - O(n) 검색 비용
- 색인
    - 일반적인 개념은 어떤 부가적인 메타데이터를 유지하는 것. 
    - 어떤 종류의 색인이라도 쓰기 속도를 느리게 만든다 
        - 이는 데이터 쓸 때마다 매번 색인도 갱신해야 하기 때문
        - 저장소 시스템에서의 트레이드 오프
            - 색인을 잘 선택하면 읽기 질의 속도가 올라가지만 모든 색인은 쓰기 속도를 떨어뜨린다
        - 개발자나 데이터베이스 관리자가 수동으로 적절 색인 선택해야 함.
    
- 해시 색인
    - 키-값 데이터의 색인은 보통 해시맵으로 구현한다. 
    - 예제처럼 단순히 파일에 추가하는 방식으로 데이터 저장소를 구성한다고 가정할 때 간단하게 가능한 색인 전략
        - 키를 데이터 파일의 바이트 오프셋에 매핑해 인메모리 해시 맵을 유지
        - 파일에 새로운 키-값 쌍 추가할 때 마다 방금 기록한 데이터의 오프셋 반영을 위해 해시맵 갱신 필요
        - 값을 조회 하려면 해시맵을 사용해 데이터 파일에서 오프셋을 찾아 해당 위치를 구하고 값을 읽는다.
        - 비트캐스크(리악의 기본 저장소 엔진)가 근본적으로 사용하는 방식
    - 각 키의 값이 자주 갱신되는 상황에 매우 적합
        - ex) 키는 동영상 URL, 값은 비디오가 재생된 횟수
        - 키당 쓰기 수가 많지만 메모리에 모든 키를 보관 가능
    - 디스크 공간 부족 대처
        - 항상 추가만 하면 결국 디스크 공간 부족해짐
        - 특정 크기의 세그먼트로 로그를 나누는 방식이 좋은 해결책
        - 특정 크기에 도달하면 세그먼트 파일을 닫고 새로운 세그먼트 파일에 쓰기 수행
        - 세그먼트 파일들에 대해 컴팩션 수행
            - 컴팩션은 로그에서 중복된 키를 버리고 각 키의 최신 갱신 값만 유지 하는 것
        - 컴팩션 수행 시 동시에 여러 세그먼트 병합 가능
        - 세그먼트가 쓰여진 후 절대 변경 불가능하므로 병합할 세그먼트는 새로운 파일로 생성
            - 컴팩션 수행 중 이전 세그먼트 파일 사용해 읽기와 쓰기 요청 처리 정상적으로 수행 가능
            - 병합 종료 후 읽기 요청은 이전 세그먼트 대신 새로 병합한 세그먼트 사용하게 전환 
            - 전환 후 이전 세그먼트 파일은 삭제
        - 각 세그먼트는 키를 파일 오프셋에 매핑한 자체 인메모리 해시 테이블을 가진다. 
    - 실제 구현에서 중요한 문제
        - 파일 형식
            - CSV 보단 바이트 단위의 문자열 길이를 부호화한 다음 원시 문자열을 부호화 하는 바이너리 형식 사용하는 편이 더 빠르고 간단
        - 레코드 삭제
            - 키와 관련된 데이터 삭제 시 데이터 파일에 특수한 삭제 레코드(툼스톤) 추가 필요
        - 고장(crash) 복구
            - DB가 재시작되면 인메모리 해시맵이 소멸됨. 각 세그먼트 해시맵의 스냅숏을 디스크에 저장해 복구 속도 높인다.
        - 부분적 레코드 쓰기
            - DB는 로그에 레코드를 추가하는 도중에도 죽을 수 있다. 파일이 체크섬을 가지고 있으면 로그의 손상된 부분을 탐지해 무시할 수 있다.
        - 동시성 제어
            - 쓰기를 엄격하게 순차적으로 로그에 추가 시 일반적인 구현바업은 하나의 쓰기 스레드만 사용
            - 데이터 파일 세그먼트는 추가 전용이거나 불변이므로 다중 스레드로 동시에 읽기할 수 있다. 
    - 추가 전용(append-only) 설계의 장점
        - 추가와 세그먼트 병합은 순차적인 쓰기 작업이기 때문에 보통 무작위 쓰기보다 훨씬 빠르다. 
        - 세그먼트 파일이 추가 전용이나 불변이면 동시성과 고장 복구과 훨씬 간단. 
        - 오래된 세그먼트 병합은 조각화 되면 데이터 파일 문제 회피 가능
    - 해시 테이블 색인 제한 사항
        - 키가 너무 많으면 메모리 저장이 어려워진다.
            - 디스크에도 해시 맵 유지 가능하지만 좋은 성능 기대 어려움
            - 디스크에선 무작위 접근 I/O가 많이 필요하고 디스크 가득 찼을 때 확장 비용이 비싸며 해시 충돌 해소를 위한 성가신 로직 필요
        - 범위 질의(range query)에 효율적이지 않다. 


