# 저장소와 검색

- 특정 작업부하(workload) 유형에서 좋은 성능을 내게끔 저장소 엔진을 조정하려면 저장소 엔진이 내부에서 수행된느 작업에 대해 대략적인 개념을 이해할 필요가 있다.
- 트랜잭션 작업부하게 맞춰 최적화된 저장소 엔진과, 분석을 위해 최적화된 엔진 간에는 큰 차이가 있음
- 이번 장에서는 관계형 DB, NoSQL DB에서 사용하는 저장소 엔진에 대해 설명
- 그리고 log structured, page-oriented 계열 저장소 엔진 검토

## 데이터베이스를 강력하게 만드는 데이터 구조
- 많은 데이터베이스는 내부적으로 추가 전용(append-only) 데이터 파일인 로그를 사용
    - 이 책에서 로그는 연속된 추가 전용 레코드를 의미
- 키-값 저장소에서 색인이 없으면 매번 키를 찾을 때 마다 전체 데이터베이스 파일을 처음부터 끝까지 스캔해야 한다
    - O(n) 검색 비용
- 색인
    - 일반적인 개념은 어떤 부가적인 메타데이터를 유지하는 것. 
    - 어떤 종류의 색인이라도 쓰기 속도를 느리게 만든다 
        - 이는 데이터 쓸 때마다 매번 색인도 갱신해야 하기 때문
        - 저장소 시스템에서의 트레이드 오프
            - 색인을 잘 선택하면 읽기 질의 속도가 올라가지만 모든 색인은 쓰기 속도를 떨어뜨린다
        - 개발자나 데이터베이스 관리자가 수동으로 적절 색인 선택해야 함.
    
- 해시 색인
    - 키-값 데이터의 색인은 보통 해시맵으로 구현한다. 
    - 예제처럼 단순히 파일에 추가하는 방식으로 데이터 저장소를 구성한다고 가정할 때 간단하게 가능한 색인 전략
        - 키를 데이터 파일의 바이트 오프셋에 매핑해 인메모리 해시 맵을 유지
        - 파일에 새로운 키-값 쌍 추가할 때 마다 방금 기록한 데이터의 오프셋 반영을 위해 해시맵 갱신 필요
        - 값을 조회 하려면 해시맵을 사용해 데이터 파일에서 오프셋을 찾아 해당 위치를 구하고 값을 읽는다.
        - 비트캐스크(리악의 기본 저장소 엔진)가 근본적으로 사용하는 방식
    - 각 키의 값이 자주 갱신되는 상황에 매우 적합
        - ex) 키는 동영상 URL, 값은 비디오가 재생된 횟수
        - 키당 쓰기 수가 많지만 메모리에 모든 키를 보관 가능
    - 디스크 공간 부족 대처
        - 항상 추가만 하면 결국 디스크 공간 부족해짐
        - 특정 크기의 세그먼트로 로그를 나누는 방식이 좋은 해결책
        - 특정 크기에 도달하면 세그먼트 파일을 닫고 새로운 세그먼트 파일에 쓰기 수행
        - 세그먼트 파일들에 대해 컴팩션 수행
            - 컴팩션은 로그에서 중복된 키를 버리고 각 키의 최신 갱신 값만 유지 하는 것
        - 컴팩션 수행 시 동시에 여러 세그먼트 병합 가능
        - 세그먼트가 쓰여진 후 절대 변경 불가능하므로 병합할 세그먼트는 새로운 파일로 생성
            - 컴팩션 수행 중 이전 세그먼트 파일 사용해 읽기와 쓰기 요청 처리 정상적으로 수행 가능
            - 병합 종료 후 읽기 요청은 이전 세그먼트 대신 새로 병합한 세그먼트 사용하게 전환 
            - 전환 후 이전 세그먼트 파일은 삭제
        - 각 세그먼트는 키를 파일 오프셋에 매핑한 자체 인메모리 해시 테이블을 가진다. 
    - 실제 구현에서 중요한 문제
        - 파일 형식
            - CSV 보단 바이트 단위의 문자열 길이를 부호화한 다음 원시 문자열을 부호화 하는 바이너리 형식 사용하는 편이 더 빠르고 간단
        - 레코드 삭제
            - 키와 관련된 데이터 삭제 시 데이터 파일에 특수한 삭제 레코드(툼스톤) 추가 필요
        - 고장(crash) 복구
            - DB가 재시작되면 인메모리 해시맵이 소멸됨. 각 세그먼트 해시맵의 스냅숏을 디스크에 저장해 복구 속도 높인다.
        - 부분적 레코드 쓰기
            - DB는 로그에 레코드를 추가하는 도중에도 죽을 수 있다. 파일이 체크섬을 가지고 있으면 로그의 손상된 부분을 탐지해 무시할 수 있다.
        - 동시성 제어
            - 쓰기를 엄격하게 순차적으로 로그에 추가 시 일반적인 구현바업은 하나의 쓰기 스레드만 사용
            - 데이터 파일 세그먼트는 추가 전용이거나 불변이므로 다중 스레드로 동시에 읽기할 수 있다. 
    - 추가 전용(append-only) 설계의 장점
        - 추가와 세그먼트 병합은 순차적인 쓰기 작업이기 때문에 보통 무작위 쓰기보다 훨씬 빠르다. 
        - 세그먼트 파일이 추가 전용이나 불변이면 동시성과 고장 복구과 훨씬 간단. 
        - 오래된 세그먼트 병합은 조각화 되면 데이터 파일 문제 회피 가능
    - 해시 테이블 색인 제한 사항
        - 키가 너무 많으면 메모리 저장이 어려워진다.
            - 디스크에도 해시 맵 유지 가능하지만 좋은 성능 기대 어려움
            - 디스크에선 무작위 접근 I/O가 많이 필요하고 디스크 가득 찼을 때 확장 비용이 비싸며 해시 충돌 해소를 위한 성가신 로직 필요
        - 범위 질의(range query)에 효율적이지 않다. 
    
- SS테이블과 LSM 트리
    - SS테이블
        - Sorted String Table
        - 조건 
            - 키로 정렬된 테이블
            - 각 키는 각 병합된 세그먼트 파일 내에 한 번만 나타나야 한다. (컴팩션 과정은 이를 이미 보장)
        - 해시 색인 가진 로그 세그먼트 대비 장점
            - 세그먼트 병합은 파일이 사용 가능한 메모리보다 크더라도 간단하고 효율적
                - mergesort와 비슷한 방식
                - 먼저 입력 파일을 함께 읽고 각 파일의 첫 번째 키를 본다. 
                - 그리고 가장 낮은 키를 출력 파일로 복사한 뒤 이 과정을 반복
                - 새로운 세그먼트 파일도 키로 정렬되어 있음.
                - 만약 여러 세그먼트에 동일한 키가 있으면? 가장 최근 세그먼트의 값은 유지하고 오래된 세그먼트의 값은 버린다
                - SS테이블이 아니고, 컴팩션 대상 파일 크기가 메모리보다 클 경우 컴팩션 속도가 매우 느릴 것 같다(컨텍스트 스위칭)
            - 파일에서 특정 키를 찾기 위해 더는 메모리에 모든 키의 색인을 유지할 필요가 없다.
                - 전체 키에 대한 색인 대신 sparse index를 사용한다 
                - 예를들어 handiwork라는 키를 찾고자 할 때 sparse index에 handbag과 handsome이 있다면 두 키의 오프셋 사이를 스캔하면 된다.
                - 수 킬로 바이트 정도는 매우 빠르게 스캔할 수 있으므로 세그먼트 파일 내 수 킬로바이트당 키 하나로 충분
            - 디스크 공간 절약 및 I/O 대역폭 사용 줄임
                - 읽기 요청은 범위내에서 여러 키-값 쌍을 스캔해야 하므로 해당 레코드들을 블록으로 그룹화 하고 디스크에 쓰기전 압축한다.
                - sparse index 각 항목은 압축된 블록의 시작을 가리키게 된다. 
    - SS 테이블 생성과 유지
        - 유입되는 쓰기는 임의 순서일텐데 어떻게 SS 테이블 형태를 유지하나?(키로 정렬)
            - SS테이블 동작 순서
                - 쓰기가 들어오면 인메모리 균형트리(memtable이라고도 함)에 추가
                - 멤테이블이 보통 수 메가바이트 정도의 임곗값보다 커지면 SS 테이블 파일로 디스크에 기록(DB의 가장 최신 세그먼트가 됨)
                - SS 테이블을 디스크에 기록하는 동안 쓰기는 새로운 멤테이블 인스턴스에 기록
                - 읽기 요청은 멤테이블에서 키를 찾고, 없으면 그다음 디스크상의 최신 세그먼트에서 찾음. 없을 때 마다 두번째, 세번째,... 세그먼트 파일 조회
                - 가끔 세그먼트 파일에 대한 병합과 컴팩션 수행. 이 과정은 백그라운드에서 실행 
            - 멤테이블
                - 임의 순서로 키 삽입 하고 정렬된 순서로 해당 키를 다시 읽을 수 있음.                
                - 종류
                  - 레드 블랙 트리, AVL 트리
            - DB 고장 대처
                - DB 고장 시 멤테이블(메모리에 존재)에 있는 최신 쓰기는 손실됨.
                - 이 문제 피하기 위해 매번 쓰기를 즉시 추가할 수 있게 분리된 로그를 디스크상에 유지
                - 이 로그는 손상 후 멤테이블 복원할때만 사용하므로 순서 정렬되지 않아도 괜찮음.
                - 멤테이블을 SS 테이블로 기록하면 해당 로그는 버릴 수 있다.
    - SS 테이블에서 LSM 트리 만들기
        - LSM 트리: Log-Structured Merge-Tree (로그 구조화 병합 트리)
        - LSM 저장소 엔진: 정렬된 파일 병합과 컴팩션 원리를 기반으로 하는 저장소 엔진
        - LevelDB, RocksDB에서 사용, 카산드라와 HBase도 유사한 저장소 엔진 사용
        - 루씬은 ES나 솔라에서 사용하는 전문(full-text) 검색 색인 엔진이고, 용어 사전을 저장하기 위해 유사한 방법 사용
        - 이 부분에서 말하고자하는건 SS테이블을 통해 LSM 트리가 구성될 수 있다인듯
        
    - 성능 최적화
        - 블룸 필터(Bloom filter)
            - LSM 트리 알고리즘은 DB에 존재하지 않는 키 찾을 경우 느릴 수 있다.
            - 존재하지 않음을 확인하려면 가장 오래된 세그먼트까지 거슬러가야함
            - 블룸필터는 집합 내용을 근사한(approximating) 메모리 효율적 데이터 구조
            - 블룸 필터는 키가 데이터베이스에 존재하지 않음을 알려줘서 불필요한 디스크 읽기 절약 가능
        - SS 테이블 압축 및 병합의 순서와 시기 결정 전략
            - size-tiered(사이즈 계층)
                - HBase, 카산드라 지원
                - 상대적으로 좀 더 새롭고 작은 SS테이블을 상대적으로 오래됐고 큰 SS테이블에 연이어 병합
            - leveled compaction
                - 키 범위를 더 작은 SS테이블로 나누고 오래된 데이터는 개별 "레벨"로 이동
                - 컴팩션을 점진적으로 진행해 디스크 공간을 덜 사용
    
- B트리
    - 가장 널리 사용되는 색인 구조
    - SS테이블과 같이 키로 정렬된 키-값 쌍을 유지하기 때문에 키-값 검색과 범위 질의에 효율적
    - 전통적으로 4KB 크기(때로는 더 큰)의 고정 크기 블록이나 페이지로 나누고 한 번에 하나의 페이지에 읽기 또는 쓰기
    - 각 페이지는 주소나 위치를 이용해 식별
    - 하나의 페이지가 다른 페이지를 참조 가능
    - 한 페이지는 B트리의 root로 지정되고, 색인에서 키를 찾으려면 루트에서 시작한다. 
    - 최종적으로는 개별키(leaf page)를 포함하는 페이지 도달. 이 페이지는 각 키의 값을 포함하거나 값을 찾을 수 있는 페이지의 참조를 포함
    - 분기 계수(branching factor): 한 페이지에서 하위 페이지 참조하는 수
    - 키의 값을 갱신하려면 키를 포함하고 있는 리프 페이지를 검색하고 페이지의 값을 바꾼 후 디스크에 다시 기록
    - 새로운 키 추가는 새로운 키를 포함하는 범위의 페이지를 찾아 해당 페이지에 키와 값을 추가한다.
        - 새로운 키 수용한 페이지에 여유공간이 없다면 페이지 하나를 반쯤 채워지 페이지 둘로 나누고 상위 페이지가 새로운 키 범위의 하위 부분들을 알 수 있게 갱신
    - n개의 키를 가진 B트리는 깊이가 항상 O(log n)
    - 분기 계수 500, 4KB 페이지의 4단계(깊이) 트리는 256TB 까지 저장 가능
            
                    


