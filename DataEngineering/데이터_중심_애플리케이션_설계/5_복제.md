# 복제

- 복제란 네트워크로 연결된 여러 장비에 동일한 데이터의 복사본을 유지하는 것
- 복제가 필요한 여러 이유
    - 지리적으로 사용자와 가깝게 데이터를 유지해 지연시간 줄인다
    - 시스템의 일부에 장애가 발생해도 지속적으로 동작할 수 있게 해 가용성을 높인다
    - 읽기 질의를 제공하는 장비의 수를 확장해 읽기 처리량을 높인다
    
- 복제에서 모든 어려움은 복제된 데이터의 변경 처리에 있음
- 복제를 위한 인기 있는 알고리즘 세가지
    - 단일 리더(single-leader)
    - 다중 리더(multi-leader)
    - 리더 없는(leaderless)
    
- 복제는 오래된 주제(1970년대 연구된 이래로 원리는 많이 변하지 않음)
    - 네트워크의 근본적인 제약 조건이 그때와 같기 때문
    
    
## 리더와 팔로워

- 복제 서버(replica): DB의 복사본을 저장하는 노드
- 복제 서버에서 동일한 데이터를 유지하는 방법: DB의 모든 쓰기는 모든 복제 서버에서 처리된다.
    - 리더 기반 복제(leader-based replication)(또는 active/passive, master/slave): 이 문제를 위한 가장 일반적인 해결책
        - 리더(leader)(또는 master, primary): 복제 서버 중 하나를 지정
            - 데이터베이스 쓰기 시 리더에게만 요청 보내야함
            - 쓰기 요청 시 로컬 저장소에 새로운 데이터 기록
            - 이후 데이터 변경을 복제 로그(replication log)나 변경 스트림(change stream)의 일부로 팔로워에게 전송
        - 팔로워(follower)(또는 read replica, slave, secondary, hot standby): 리더 제외한 다른 복제 서버
            - 읽기 시 팔로워에게도 질의 가능
- 복제 모드 지원 
    - RDB: mysql, postgres(9.0부터) 등 
    - NoSQL: mongoDB, 에스프레소 등
    - 분산 메시지 브로커: Kafka, RabbitMQ 등
    
- 동기식 대 비동기식 복제
    - 복제가 동기식인지, 비동기식인지는 중요한 세부 사항이다.
    - 동기식 복제
        - 장점
            - 팔로워가 리더와 일관성이 있게 최신 데이터 복사본을 가지는 것을 보장
        - 단점
            - 동기 팔로워가 응답하지 않으면 쓰기가 처리될 수 없다
            - 리더는 모든 쓰기를 차단하고 동기 복제 서버가 다시 사용할 수 있을 때 까지 기다려야 함
        - 모든 팔로워가 동기식인 상황은 비현실적
        - 임의 한 노드의 장애는 전체 시스템을 멈추게 함
    - 반동기식
        - 팔로워 하나는 동기식으로 하고 그 밖에는 비동기식으로 하는 것
        - 동기식 팔로워가 느려지거나 사용할 수 없게 되면 비동기식 팔로워 중 하나가 동기식이 된다.
    - 비동기식
        - 리더 기반 복제는 보통 완전 비동기식으로 구성
        - 장점
            - 모든 팔로워가 잘못되더라도 리더가 쓰기 처리를 계속 할 수 있음.
        - 단점
            - 리더가 잘못되고 복구할 수 없으면 팔로워에 아직 복제되지 않은 모든 쓰기는 유실
                - 쓰기가 클라이언트에 확인된 경우에도 지속성을 보장하지 않는다는 의미
    
        - 특히 많은 팔로워가 있거나 지리적으로 분산됐다면 비동기식 복제를 널리 사용한다.
    
- 새로운 팔로워 설정
    - 사용하는 상황
        - 복제 서버 수 늘리기
        - 장애 노드 대체
    - 과정(무중단)
        - 리더의 DB 스냅숏을 일정 시점에 가져옴
        - 스냅숏을 새로운 팔로워 노드에 복사
        - 팔로워는 리더에 연결하여 스냅숏 이후 발생한 모든 데이터 변경을 요청
            - 스냅숏이 리더의 복제 로그의 정확한 위치와 연관돼야 함
            - 위치의 명칭은 postgres에서 로그 일련번호(log sequence number), mysql에서 이진로그 좌표(binlog coordinate)라고 불림.
        - 팔로워가 스냅숏 이후 데이터 변경의 미처리분(backlog)을 모두 처리했을 때 따라잡았다고 말함. 
    
- 노드 중단 처리
    - 시스템의 모든 노드는 아래와 같은 이유로 중단될 수 있다
        - 노드 장애
        - 계획된 유지보수
    - 팔로워 장애: 따라잡기 복구
        - 팔로워는 리더로부터 수신한 데이터를 디스크에 보관
        - 팔로워 장애 발생시
            - 결함이 발생하기 전 처리한 마지막 트랜잭션을 알아낸다
            - 마지막 트랜잭션 이후 발생한 데이터 변경 요청(따라잡기) 
    - 리더 장애: 장애 복구
        - 장애 복구(fail over)
            - 팔로워 중 하나를 새로운 리더로 승격
            - 클라이언트는 새로운 리더로 쓰기 전송하도록 재설정
            - 팔로워는 새로운 리더로부터 데이터 소비하도록 설정
            - 단계
                - 리더가 장애인지 판단: 타임아웃 사용
                - 새로운 리더 선택: 가장 적합한 후보는 이전 리더의 최신 데이터 변경사항 가진 복제 서버
                - 새로운 리더 사용을 위한 재설정: 이전 리더가 팔로워고 새로운 리더를 인식할 수 있게끔 해야함
            - 문제 발생 가능 포인트
                - 비동기식 복제의 경우 이전 리더의 복제되지 않은 쓰기 존재 가능. 이 때 이전 리더가 클러스터에 다시 추가된다면
                    - 일반적인 해결책은 이전 리더의 복제되지 않은 쓰기를 폐기
                        - 내구성에 대한 클라이언트의 기대를 저버리는 것
                        - 외부의 다른 저장소 시스템이 db 내용에 맞춰 조정돼야 하면 위험(github 사례)
                - 스플릿 브레인(split brain)
                    - 두 노드가 모두 자신이 리더라고 믿는 경우
                    - 두 리더 쓰기의 충돌 해소 과정이 없다면 데이터 유실되거나 오염 
                    
                - 적절한 타임아웃 설정
                    - 긴 타임아웃: 복구에 오랜 시간 소요
                    - 짧은 타임아웃: 불필요한 장애 복구 발생 가능
            - 위 문제에 쉬운 해결책은 없음. 
            - 일부 운영팀은 자동 장애 복구 지원하더라도 수동으로 장애 복구 수행하는 방식 선호
    
- 복제 로그 구현
    - 구문 기반 복제
        - 리더는 모든 쓰기 요청(구문(statement))을 기록하고 쓰기를 실행한 다음 구문 로그를 팔로워에게 전송
        - RDB는 INSERT, UPDATE, DELETE 등 구문을 전달
        - 팔로워는 클라이언트에서 직접 받은 것 처럼 구문 파싱 및 실행
        - 복제 깨지는 사례
            - 비결정적 함수 호출 하는 구문(NOW, RAND 등)
            - 자동 증가 컬럼 
            - 데이터 값에 의존하는 구문 (ex. UPDATE ... WHERE < some condition)
        - 해결책
            - 리더는 구문 기록시 비결정적 함수 호출을 고정값 반환하게끔 대체할 수 있음
        - 사용 사례
            - 매우 간편해서 오늘날에도 여전히 사용
            - mysql 5.1 이전 버전에서 사용됨. 이제는 구문에 비결정성이 있다면 로우 기반 복제로 변경
            - 볼트 DB도 구문 기반 사용하고, 트랜잭션이 결정적이게끔 요구
            
    - 쓰기 전 로그 배송
        - log-structured, page-oriented 저장소 엔진 모두 모든 쓰기는 로그에 기록한다
        - 로그를 팔로워에게 네트워크로 전송하고 팔로워가 이를 처리하면 동일한 데이터 구조의 복제본이 만들어짐. 
        - 사용 사례
            - postgres
            - oracle
        - 단점
            - 저수준의 데이터를 기술 -> 복제가 저장소 엔진과 밀접하게 엮임
            - DB가 저장소 형식을 다른 버전으로 변경한다면 리더와 팔로워의 DB 소프트웨어 버전을 다르게 실행할 수 없음.
            - 버전의 불일치 허용은 무중단 운영을 가능하게 하는 중요한 요소 
    - 논리적(로우 기반) 로그 복제
        - 복제 로그를 저장소 엔진 내부와 분리하기 위한 대안
        - 저장소 엔진의 (물리적) 데이터 표현과 구별하기 위해 논리적 로그(logical log)라고 부른다.
        - RDB용 논리적 로그는 로우 단위로 DB 테이블에 쓰기를 기술한 레코드 열
        - 사용 사례
            - mysql 이진 로그
        - 장점
            - 논리적 로그를 저장소 엔진 내부와 분리했기 때문에 하위 호환성 더 쉽게 유지 가능
            - 리더와 팔로워에서 다른 버전의 DB 소프트웨어나 다른 저장소 엔진 실행 가능
            - 논리적 로그 형식은 외부 애플리케이션이 파싱하기 더 쉬움
                - 외부 시스템에 DB 내용 전송할 때 유용(변경 데이터 캡쳐(change data capture))
      
    - 트리거 기반 복제
        - 유연성이 필요한 상황에서 사용
            - ex) 
                - 데이터 서브셋만 복제
                - DB를 다른 종류의 DB로 복제
                - 충돌해소 로직 필요시
        - 복제를 애플리케이션층으로 옮긴 것
        - 사용 방법
            - 오라클의 골든 게이트
            - RDB의 트리거나 스토어드 프로시저
        - 다른 복제 방식보다 많은 오버헤드
            - DB에 내장된 복제보다 버그나 제한 사항이 많음. 그럼에도 유연성 때문에 매우 유용