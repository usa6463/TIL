# 복제

- 복제란 네트워크로 연결된 여러 장비에 동일한 데이터의 복사본을 유지하는 것
- 복제가 필요한 여러 이유
    - 지리적으로 사용자와 가깝게 데이터를 유지해 지연시간 줄인다
    - 시스템의 일부에 장애가 발생해도 지속적으로 동작할 수 있게 해 가용성을 높인다
    - 읽기 질의를 제공하는 장비의 수를 확장해 읽기 처리량을 높인다
    
- 복제에서 모든 어려움은 복제된 데이터의 변경 처리에 있음
- 복제를 위한 인기 있는 알고리즘 세가지
    - 단일 리더(single-leader)
    - 다중 리더(multi-leader)
    - 리더 없는(leaderless)
    
- 복제는 오래된 주제(1970년대 연구된 이래로 원리는 많이 변하지 않음)
    - 네트워크의 근본적인 제약 조건이 그때와 같기 때문
    
    
## 리더와 팔로워

- 복제 서버(replica): DB의 복사본을 저장하는 노드
- 복제 서버에서 동일한 데이터를 유지하는 방법: DB의 모든 쓰기는 모든 복제 서버에서 처리된다.
    - 리더 기반 복제(leader-based replication)(또는 active/passive, master/slave): 이 문제를 위한 가장 일반적인 해결책
        - 리더(leader)(또는 master, primary): 복제 서버 중 하나를 지정
            - 데이터베이스 쓰기 시 리더에게만 요청 보내야함
            - 쓰기 요청 시 로컬 저장소에 새로운 데이터 기록
            - 이후 데이터 변경을 복제 로그(replication log)나 변경 스트림(change stream)의 일부로 팔로워에게 전송
        - 팔로워(follower)(또는 read replica, slave, secondary, hot standby): 리더 제외한 다른 복제 서버
            - 읽기 시 팔로워에게도 질의 가능
- 복제 모드 지원 
    - RDB: mysql, postgres(9.0부터) 등 
    - NoSQL: mongoDB, 에스프레소 등
    - 분산 메시지 브로커: Kafka, RabbitMQ 등
    
- 동기식 대 비동기식 복제
    - 복제가 동기식인지, 비동기식인지는 중요한 세부 사항이다.
    - 동기식 복제
        - 장점
            - 팔로워가 리더와 일관성이 있게 최신 데이터 복사본을 가지는 것을 보장
        - 단점
            - 동기 팔로워가 응답하지 않으면 쓰기가 처리될 수 없다
            - 리더는 모든 쓰기를 차단하고 동기 복제 서버가 다시 사용할 수 있을 때 까지 기다려야 함
        - 모든 팔로워가 동기식인 상황은 비현실적
        - 임의 한 노드의 장애는 전체 시스템을 멈추게 함
    - 반동기식
        - 팔로워 하나는 동기식으로 하고 그 밖에는 비동기식으로 하는 것
        - 동기식 팔로워가 느려지거나 사용할 수 없게 되면 비동기식 팔로워 중 하나가 동기식이 된다.
    - 비동기식
        - 리더 기반 복제는 보통 완전 비동기식으로 구성
        - 장점
            - 모든 팔로워가 잘못되더라도 리더가 쓰기 처리를 계속 할 수 있음.
        - 단점
            - 리더가 잘못되고 복구할 수 없으면 팔로워에 아직 복제되지 않은 모든 쓰기는 유실
                - 쓰기가 클라이언트에 확인된 경우에도 지속성을 보장하지 않는다는 의미
    
        - 특히 많은 팔로워가 있거나 지리적으로 분산됐다면 비동기식 복제를 널리 사용한다.
    
- 새로운 팔로워 설정
    - 사용하는 상황
        - 복제 서버 수 늘리기
        - 장애 노드 대체
    - 과정(무중단)
        - 리더의 DB 스냅숏을 일정 시점에 가져옴
        - 스냅숏을 새로운 팔로워 노드에 복사
        - 팔로워는 리더에 연결하여 스냅숏 이후 발생한 모든 데이터 변경을 요청
            - 스냅숏이 리더의 복제 로그의 정확한 위치와 연관돼야 함
            - 위치의 명칭은 postgres에서 로그 일련번호(log sequence number), mysql에서 이진로그 좌표(binlog coordinate)라고 불림.
        - 팔로워가 스냅숏 이후 데이터 변경의 미처리분(backlog)을 모두 처리했을 때 따라잡았다고 말함. 
    
- 노드 중단 처리
    - 시스템의 모든 노드는 아래와 같은 이유로 중단될 수 있다
        - 노드 장애
        - 계획된 유지보수
    - 팔로워 장애: 따라잡기 복구
        - 팔로워는 리더로부터 수신한 데이터를 디스크에 보관
        - 팔로워 장애 발생시
            - 결함이 발생하기 전 처리한 마지막 트랜잭션을 알아낸다
            - 마지막 트랜잭션 이후 발생한 데이터 변경 요청(따라잡기) 
    - 리더 장애: 장애 복구
        - 장애 복구(fail over)
            - 팔로워 중 하나를 새로운 리더로 승격
            - 클라이언트는 새로운 리더로 쓰기 전송하도록 재설정
            - 팔로워는 새로운 리더로부터 데이터 소비하도록 설정
            - 단계
                - 리더가 장애인지 판단: 타임아웃 사용
                - 새로운 리더 선택: 가장 적합한 후보는 이전 리더의 최신 데이터 변경사항 가진 복제 서버
                - 새로운 리더 사용을 위한 재설정: 이전 리더가 팔로워고 새로운 리더를 인식할 수 있게끔 해야함
            - 문제 발생 가능 포인트
                - 비동기식 복제의 경우 이전 리더의 복제되지 않은 쓰기 존재 가능. 이 때 이전 리더가 클러스터에 다시 추가된다면
                    - 일반적인 해결책은 이전 리더의 복제되지 않은 쓰기를 폐기
                        - 내구성에 대한 클라이언트의 기대를 저버리는 것
                        - 외부의 다른 저장소 시스템이 db 내용에 맞춰 조정돼야 하면 위험(github 사례)
                - 스플릿 브레인(split brain)
                    - 두 노드가 모두 자신이 리더라고 믿는 경우
                    - 두 리더 쓰기의 충돌 해소 과정이 없다면 데이터 유실되거나 오염 
                    
                - 적절한 타임아웃 설정
                    - 긴 타임아웃: 복구에 오랜 시간 소요
                    - 짧은 타임아웃: 불필요한 장애 복구 발생 가능
            - 위 문제에 쉬운 해결책은 없음. 
            - 일부 운영팀은 자동 장애 복구 지원하더라도 수동으로 장애 복구 수행하는 방식 선호
    
- 복제 로그 구현
    - 구문 기반 복제
        - 리더는 모든 쓰기 요청(구문(statement))을 기록하고 쓰기를 실행한 다음 구문 로그를 팔로워에게 전송
        - RDB는 INSERT, UPDATE, DELETE 등 구문을 전달
        - 팔로워는 클라이언트에서 직접 받은 것 처럼 구문 파싱 및 실행
        - 복제 깨지는 사례
            - 비결정적 함수 호출 하는 구문(NOW, RAND 등)
            - 자동 증가 컬럼 
            - 데이터 값에 의존하는 구문 (ex. UPDATE ... WHERE < some condition)
        - 해결책
            - 리더는 구문 기록시 비결정적 함수 호출을 고정값 반환하게끔 대체할 수 있음
        - 사용 사례
            - 매우 간편해서 오늘날에도 여전히 사용
            - mysql 5.1 이전 버전에서 사용됨. 이제는 구문에 비결정성이 있다면 로우 기반 복제로 변경
            - 볼트 DB도 구문 기반 사용하고, 트랜잭션이 결정적이게끔 요구
            
    - 쓰기 전 로그 배송
        - log-structured, page-oriented 저장소 엔진 모두 모든 쓰기는 로그에 기록한다
        - 로그를 팔로워에게 네트워크로 전송하고 팔로워가 이를 처리하면 동일한 데이터 구조의 복제본이 만들어짐. 
        - 사용 사례
            - postgres
            - oracle
        - 단점
            - 저수준의 데이터를 기술 -> 복제가 저장소 엔진과 밀접하게 엮임
            - DB가 저장소 형식을 다른 버전으로 변경한다면 리더와 팔로워의 DB 소프트웨어 버전을 다르게 실행할 수 없음.
            - 버전의 불일치 허용은 무중단 운영을 가능하게 하는 중요한 요소 
    - 논리적(로우 기반) 로그 복제
        - 복제 로그를 저장소 엔진 내부와 분리하기 위한 대안
        - 저장소 엔진의 (물리적) 데이터 표현과 구별하기 위해 논리적 로그(logical log)라고 부른다.
        - RDB용 논리적 로그는 로우 단위로 DB 테이블에 쓰기를 기술한 레코드 열
        - 사용 사례
            - mysql 이진 로그
        - 장점
            - 논리적 로그를 저장소 엔진 내부와 분리했기 때문에 하위 호환성 더 쉽게 유지 가능
            - 리더와 팔로워에서 다른 버전의 DB 소프트웨어나 다른 저장소 엔진 실행 가능
            - 논리적 로그 형식은 외부 애플리케이션이 파싱하기 더 쉬움
                - 외부 시스템에 DB 내용 전송할 때 유용(변경 데이터 캡쳐(change data capture))
      
    - 트리거 기반 복제
        - 유연성이 필요한 상황에서 사용
            - ex) 
                - 데이터 서브셋만 복제
                - DB를 다른 종류의 DB로 복제
                - 충돌해소 로직 필요시
        - 복제를 애플리케이션층으로 옮긴 것
        - 사용 방법
            - 오라클의 골든 게이트
            - RDB의 트리거나 스토어드 프로시저
        - 다른 복제 방식보다 많은 오버헤드
            - DB에 내장된 복제보다 버그나 제한 사항이 많음. 그럼에도 유연성 때문에 매우 유용
    
- 복제 지연 문제
    - 복제 사용 이유
        - 내결함성
        - 확장성: 단일 장비에서 감당 못하는 요청을 처리
        - 지연 시간: 사용자에게 지리적으로 더 가까운 복제 서버 제공
    - 읽기 확장(read-scaling)
        - 리더 기반 복제에서 쓰기는 리더를 거쳐야 하지만 읽기는 어떤 팔로워에서도 가능
        - 대부분이 읽기 요청이고 쓰기가 아주 작은 비율로 구성된 작업부하(웹 상의 공통 패턴)에서 유용
        - 팔로워들에게 읽기 요청 분산
            - 리더의 부하 제거
            - 근처 복제 서버에서 읽기 요청 처리
    - 실제로는 비동기식 복제에서만 동작
        - 동기식에선 단일 노드 장애나 네트워크 중단으로 시스템 쓰기 불가능해짐. 
    - 복제 지연
        - 비동기 팔로워에서 데이터 읽을 때 팔로워가 최신화 안되어 있어 문제 발생 가능
            - 지난 정보를 읽게 됨
            - 리더와 팔로워에 동일한 질의 해도 결과가 다름
        - 지연은 수 초에서 수 분으로 증가 가능 (시스템 가용량 근처에서 동작하거나 네트워크 문제 있을 때)
    - 최종적 일관성
        - 지연으로 인한 불일치는 일시적인 상태이고, DB에 쓰기 멈추고 기다리면 팔로워가 결국 따라 잡게 되어 리더와 일치하게 된다.
    - 발생 가능 사례
        - 자신이 쓴 내용 읽기
            - 사용자가 쓰기 수행한 직후 데이터를 읽는다면 복제 서버에 새로운 데이터가 아직 반영되지 않았을 수 있음
            - 해결책
                - 쓰기후 읽기 일관성(자신의 쓰기 읽기 일관성)
                    - 사용자가 페이지를 재로딩했을 때 자신이 제출한 모든 갱신을 볼 수 있음을 보장하며 다른 사용자에 대해선 보장하지 않음
                    - 구현 방법
                        1. 사용자가 수정한 내용을 읽을 때는 리더에서 읽는다.
                        2. 기준 추가
                            - 단순히 1의 방법으론 읽기 확장의 이점이 무효화 되므로 기준을 추가한다.
                            - ex)
                                - 마지막 갱신 시각을 찾아서 마지막 갱신 후 1분 동안은 리더에서 읽기 수행
                                - 팔로워에서 복제 지연을 모니터링해 리더보다 1분 이상 늦은 모든 팔로워에 대한 질의 금지
                        3. 가장 최근의 쓰기 타임 스탬프 사용
                            - 클라이언트는 가장 최근의 쓰기 타임 스탬프 기억 가능
                            - 사용자 읽기를 위한 복제 서버가 해당 타임스탬프까지 갱신되어 있지 않은지 확인 가능
                            - 타임스탬프 까지 복제되어 있지 않다면 다른 복제 서버에서 처리하거나, 따라 잡을 때 까지 질의 대기
                - 디바이스 간(cross-device) 쓰기 후 읽기 일관성
                    - 가장 최근의 쓰기 타임스탬프 사용 어려움
                        - 한 디바이스에서 수행 중인 코드는 다른 디바이스에서 발생한 갱신 알 수 없기 때문
                        - 이 메타데이터는 중앙집중식으로 관리 필요
                    - 복제 서버가 여러 데이터센터에 분산된 경우
                        - 디바이스들의 연결이 동일한 데이터센터로 라우팅 된다는 보장 없음
                        - 리더에서 읽어야 할 필요가 있는 접근법이라면 사용자 디바이스의 요청을 동일한 데이터센터로 라우팅 필요
    
        - 단조 읽기
            - 사용자가 시간이 거꾸로 흐르는 현상 목격
            - 발생 상황
                - 사용자가 웹 페이지를 새로고침할 때 각 요청이 임의 서버로 라우팅
            - 단조 읽기(monotonic read) 는 이런 종류의 이상 현상이 발생하지 않음을 보장
                - 강한 일간성보다는 덜하지만 최종적 일관성 보다는 더 강한 보장
            - 구현 방법
                - 각 사용자의 읽기가 항상 동일한 복제 서버에서 수행
                    - 임의 선택보다는 사용자 ID의 해시를 기반으로 복제 서버 선택
                    - 복제 서버 고장 시 사용자 질의를 다른 복제 서버로 재라우팅해야함
          
        - 일관된 순서로 읽기
            - 일관된 순서로 읽기(Consistent Prefix Read)는 일관된 순서로 일련의 쓰기가 특정 순서로 발생한다면 이 쓰기를 읽는 모든 사용자는 같은 순서로 쓰여진 내용을 보게됨을 보장한다.
            - 일관되지 않은 순서 읽기는 파티셔닝된(샤딩된) 데이터베이스에서 발생하는 특징적인 문제
                - 많은 분산 DB에서 서로 다른 파티션은 독립적으로 동작하므로
            - 해결책
                - 서로 인과성 있는 쓰기가 동일한 파티션에 기록되게끔 하는 방법 
    
    - 복제 지연을 위한 해결책
        - 앞서 설명한 것 처럼 애플리케이션이 기본 DB보다 더 강력한 보장을 제공하는 방법이 있음.
            - ex. 특정 종류의 리더에서 읽기 수행
        - 하지만 APP 단위에서 이 문제를 다루기엔 복잡해서 잘못되기 쉬움
        - 위 문제 때문에 트랜잭션이 있고, 트랜잭션은 애플리케이션이 더 단순해지기 위해 DB가 더 강력한 보장을 제공하는 방법이다.
        - 단일 노드 트랜잭션이 오랫동안 존재 했지만, 분산(복제되고 파티셔닝) 데이터베이스로 전환하는 과정에서 많은 시스템이 트랜잭션을 포기했다. 
        - 트랜잭션이 성능과 가용성 측면에서 너무 비싸기 때문에, 확장 가능 시스템에서는 어쩔 수 없이 최종 일관성을 사용해야 한다는 주장이 있음. 
    
- 다중 리더 복제 
    - 단일 리더 기반 복제의 주요 단점
        - 어떤 이유로 리더에 접근 불가능하면 DB에 쓰기 불가능
    - 다중 리더 복제
        - 쓰기를 허용하는 노드를 하나 이상 두는 것으로 구현
        - 마스터 마스터나 액티브/액티브 복제라고도 함
        - 각 리더는 동시에 다른 리더의 팔로워 역할
    - 사용 사례
        - 다중 데이터센터 운영
            - 여러 다른 데이터센터에 데이터베이스 복제 서버가 있는 경우
            - 각 데이터센터마다 리더를 둔다.
            - 각 데이터센터 내에서 보통의 리더 팔로워 복제 사용
            - 데이터센터 간에는 각 데이터 센터의 리더가 다른 데이터센터의 리더에게 변경 사항 복제
            - 단일 리더 설정과의 비교
                - 성능
                    - 단일 리더 설정에선 모든 쓰기가 인터넷을 통해 리더가 있는 데이터 센터로 이동해야 하므로 쓰기 지연 시킴(네트워크 지연)
                    - 다중 리더에선 모든 쓰기가 로컬 데이터센터에서 처리된 다음 비동기로 다른 데이터센터에 복제됨. 사용자에게는 네트워크 지연이 숨겨진다
                    - 다중 리더 설정이 사용자가 인지하기엔 더 성능 좋음. 
                - 데이터센터 중단 내성
                    - 단일 리더에선 리더가 있는 데이터센터 고장시 다른 데이터센터에서 팔로워를 리더로 승진
                    - 다중리더에선 각 데이터센터들은 서로 독립적으로 동작하고 고장난 데이터센터 온라인으로 돌아오면 복제 따라잡는다.
                - 네트워크 문제 내성
                    - 다중 리더 설정에서는 네트워크 문제에 보다 잘 견딘다
        - 오프라인 작업을 하는 클라이언트
            - 예를 들어 디바이스의 캘린더 앱
            - 모든 디바이스에는 리더처럼 동작하는 로컬 데이터베이스가 있음. 
            - 모든 디바이스 상에서 캘린더의 복제 서버 간 다중리더 복제를 비동기 방식으로 수행하는 프로세스(동기화)가 있음.
        - 협업 편집
            - ex) 구글 독스, 이더패드 
            - 문서 편집 시 변경내용을 즉시 로컬 복제 서버에 적용하고, 동일한 문서 편집하는 다른 사용자와 서버에 비동기 방식으로 복제
            - 접근 방식
                - 문서 잠금
                    - 단일 리더 복제와 동일(한곳에서만 쓰기가 발생해서 그런듯)
                    - 사용자가 편집하기 전에 문서 잠금 얻어야 하고, 다른 사용자가 편집하려면 앞선 사용자 변경이 커밋되고 잠금이 해제될때 까지 기다려야함.
                - 변경 단위를 작게하는 방식
                    - ex) 단일 키 입력으로 변경단위를 작게함
                    - 잠금을 피할 수 있지만 이 접근 방식은 충돌해소가 필요한 경우 포함해 다중 리더 복제에서 발생하는 모든 문제 야기
    - 단점
        - 동일한 데이터를 다른 두 개의 데이터센터에서 동시에 변경할 수 있다. 
        - 쓰기 충돌은 반드시 해소해야 함
        - 미묘한 설정상의 실수나 다른 데이터베이스 기능과의 뜻밖의 상호작용 가능성(자동증가 키, 트리거, 무결성 제약 등)
    
- 쓰기 충돌 다루기
    - 다중 리더 복제에서 제일 큰 문제는 쓰기 충돌
    - 동기 대 비동기 충돌 감지
        - 단일 리더
            - 첫번째 쓰기가 완료될 때까지 두번째 쓰기를 차단해 기다리게 하거나 두 번째 쓰기 트랜잭션을 중단해 사용자가 쓰기를 재시도하도록 만듬
        - 다중 리더
            - 두 쓰기는 모두 성공하며 충돌은 이후 특정 시점에서 비동기로만 감지
            - 동기식으로 만드는 방법
                - 쓰기가 성공한 사실을 사용자에게 말하기 전에 모든 복제 서버가 쓰기를 복제하기 기다리게 함
                - 다중 리더 복제의 주요 장점을 잃게 되서 의미 없음
    - 충돌 회피
        - 특정 레코드의 모든 쓰기가 동일한 리더를 거치도록 애플리케이션이 보장하면 충돌 발생하지 않음. 
        - 이걸 적용하면 사용자 관점에서 단일 리더 처럼 보임
    - 일관된 상태 수렴
        - 다중 리더 설정에선 쓰기 순서가 정해지지 않아 최종 값이 무엇인지 명확하지 않음
        - 각 복제 서버가 쓰기를 본 순서대로만 적용하면 DB는 일관성 없는 상태가 됨.
        - 모든 복제 계획은 모든 복제 서버가 최종적으로는 동일하다는 사실을 보장해야 함
        - DB는 수렴(convergent) 방식으로 충돌을 해소해야 한다
        - 수렴 충돌 해소 방법
            - 각 쓰기에 고유 ID 부여하고 가장 높은 ID를 가진 쓰기를 고름. 다른 쓰기는 버린다. 
                - 타임 스탬프를 쓰는 경우 최종 쓰기 승리(last write wins, LWW)라고 한다. 
                - 대중적이지만 데이터 유실 위험
            - 각 복제 서버에 고유 ID 부여하고 높은 숫자의 복제서버에 생긴 쓰기가 우선 적용되게 함
            - 값을 병합. 예를 들어 사전 순으로 정렬후 연결 (동일한 레코드에 abc와 efg 가 동시에 쓰였다면 abc/efg 같이 저장)
            - 명시적 데이터 구조에 충돌을 기록해 모든 정보 보존. 충돌 해소 애플리케이션 코드 작성 필요
    - 사용자 정의 충돌 해소 로직
        - 쓰기 수행 중
            - 충돌 감지하자마자 충돌 핸들러 호출
            - 핸들러는 사용자에게 충돌 내용 표시하지 않고 백그라운드 프로세스에서 빠르게 실행되야 함 
        - 읽기 수행 중
            - 충돌 감지하면 모든 충돌 쓰기 저장
            - 다음에 데이터 읽을 때 여러 버전의 데이터가 애플리케이션이 반환됨.
            - app은 사용자에게 충돌 내용 보여주거나 자동으로 충돌 해소함. 
        - 충돌 해소는 개별 로우나 문서 수준에서 적용
    
    - 다중 리더 복제 토폴로지
        - 복제 토폴로지는 쓰기를 한 노드에서 다른 노드로 전달하는 통신 경로를 설명
        - 종류
            - 원형 토폴로지
            - 별 모양 토폴로지
            - 전체 연결 토폴로지
        - 원형과 별 특징
            - 무한 복제 루프 방지를 위해 각 노드에는 고유 식별자 존재. 
                - 각 쓰기는 거치는 모든 노드의 식별자가 태깅된다.
                - 노드가 데이터 변경 받았을 때 자신의 식별자가 태깅되어 있다면 변경 사항을 무시함
            - 하나의 노드에 장애가 발생하면 다른 노드 간 복제 메시지 흐름에 방해 (단일 장애점, SPOF)
        - 전체 연결 특징
            - 일부 네트워크 연결이 다른 연결보다 빠르면 일부 복제 메시지가 다른 메시지 추월 가능
            - 이런 이벤트를 올바르게 정렬하기 위해 버전 벡트라는 기법 사용 가능
            - 많은 다중 리더 복제 시스템에서 충돌 감지 기법 제대로 구현되지 않음
                - mysql 텅스텐 리플리케이터는 충돌 감지 위한 시도조차 하지 않음
                - postgresql BDR은 쓰기의 인과적 순서 제공하지 않음

- 리더 없는 복제
    - 일부 데이터 저장소 시스템은 리더의 개념을 버리고 모든 복제 서버가 클라이언트로부터 쓰기를 직접 받을 수 있게 허용하는 접근 방식을 사용하기도 한다.
    - 아마존이 다이나모 시스템에서 사용한 후 유행 (다이나모 스타일)
    - 코디네이터 노드
        - 일부 리더 없는 복제 구현에서 클라이언트가 여러 복제 서버에 쓰기를 직접 전송
        - 반면 코디네이터 노드는 클라이언트 대신해 이를 수행
        - 리더 DB와 달리 코디네이터 노드는 특정 순서로 쓰기 수행하지 않음
    - 노드가 다운됐을 때 데이터베이스에 쓰기
        - 노드가 다운 됐을 때 리더 없는 설정에선 쓰기 처리를 계속 하기 위해 장애 복구가 필요하지 않다.
        - 노드가 다운된 동안 발생한 모든 쓰기는 해당 노드에서 누락
            - 클라이언트가 해당 노드에서 데이터 읽으면 오래된(outdated) 값을 얻음
        - 해결
            - 읽기 요청을 병렬로 여러 노드에 전송
            - 여러 노드에서 다른 응답을 받는데, 버전 숫자를 통해 최신 값을 확인
    - 읽기 복구와 안티 엔트로피
        - 사용불가능한 노드가 온라인 상태가 된 후 누락된 쓰기 따라 잡는 방법
            - 읽기 복구
                - 클라이언트가 특정 복제 서버의 값이 오래된 값인걸 알면 해당 복제 서버에 새로운 값을 다시 기록한다
                - 값을 자주 읽는 상황에서 적합
            - 안티 엔트로피 처리
                - 백그라운드 프로세스에서 작동
                - 복제 서버 간 데이터 차이를 지속적으로 찾아 누락된 데이터를 하나의 복제 서버에서 다른 서버로 복사
    - 읽기와 쓰기를 위한 정족수
        - n: 복제 서버 개수
        - w: 모든 쓰기는 w개의 노드에서 성공해야 확정
        - r: 모든 읽기는 최소한 r개의 노드에 질의
        - w+r > n 이면 읽을 때 최신 값을 얻을 것으로 기대
        - 다이나모 스타일에서의 일반적인 선택: n은 홀수, w = r = (n+1) / 2(반올림)
        - 일반적으로 읽기와 쓰기는 항상 모든 n개의 복제 서버에 병렬로 전송
        - 필요한 w나 r개 노드보다 사용 가능한 노드가 적다면 쓰기나 읽기는 에러를 반환
    - 정족수 일관성의 한계
        - 정족수 원리: 쓰기를 하는 노드 셋과 읽기를 하는 노드 셋이 겹치는걸 의도
            - 즉 읽은 노드 중에는 최신 값을 가진 노드가 하나 이상 있어야 함
        - r과 w의 값으로 노드의 과반수(n/2 초과)를 선택
            - n/2 노드 장애까지 허용해도 w+r > n 이 보장되기 때문
        - w + r > n 인 경우에도 오래된 값을 반환하는 에지 케이스 존재
            - 느슨한 정족수
            - 두개의 쓰기가 동시에 발생했을 때, 최종 쓰기 승리 적용시 시계 스큐로 인해 쓰기가 유실될 수 있음.
            - 쓰기가 읽기와 동시에 발생하면 쓰기가 일부 복제 서버에만 반영
            - 전체에서 쓰기가 성공한 서버가 w 보다 적다면 성공한 복제 서버에서 롤백하지 않음.
            - 새 값을 전달하는 노드가 고장나면 예전 값을 가진 다른 복제 서버에서 해당 데이터가 복원되고 새로운 값을 저장한 복제 서버 수가 w보다 낮아져 정족수 조건이 꺠진다
            - 모든 과정이 올바르게 동작해도 시점 문제로 에지케이스 있을 수 있음. 
        - 매개변수 w와 r로 오래된 값을 읽을 확률을 조정할 수 있지만 이를 절대적으로 보장할 순 없음.
    - 최신성 모니터링
        - DB가 최신결과를 반환하는지 여부를 애플리케이션에 알려줘야 한다
            - 복제가 명확히 뒤처진다면 원인을 조사할 수 있도록
        - 복제 지연 지표
            - 리더의 현재 위치에서 팔로워의 현재 위치를 빼면 복제 지연량 확인 가능
            - 위치: 복제 로그의 위치(로컬에 적용된 쓰기 수)
        - 리더 없는 복제 시스템에서의 모니터링
            - 쓰기가 적용된 순서를 고정할 수 없어 모니터링이 어렵다
    
    - 느슨한 정족수와 암시된 핸드오프
        - 정족수는 내결함성이 없는데, 네트워크 중단으로 다수의 DB노드와 클라이언트 연결이 끊어질 수 있다.
        - 네트워크 장애 상황에서의 대응
            - w나 r 노드 정족수를 만족하지 않는 모든 요청에 오류를 반환
            - 일단 쓰기를 받아들이고 n개 노드에는 포함되지 않지만 연결할 수 있는 노드에 기록 (느슨한 정족수)
        - 암시된 핸드오프
            - 네트워크 장애 상황 해제시 느슨한 정족수을 통해 일시적으로 수용한 모든 쓰기를 n개 노드로 전송
        - 장점
            - 쓰기 가용성 높이는데 유용
        - 단점
            - w + r > n인 경우에도 키의 최신 값을 읽는다고 보장하지 않음. 
                - 최신값이 n 이외 일부 노드에 기록될 수 있기 때문
      
    - 다중 데이터센터 운영
        - 리더 없는 복제도 동시 쓰기 충돌, 네트워크 중단, 지연 시간 급증을 허용하므로 다중 데이터 센터 운영에 적합
        - n개의 복제 서버수에는 모든 데이터 센터 노드 포함
        - 각 데이터센터마다 n개의 복제 서버 중 몇 개 보유할지 지정
        - 보통 로컬 데이터센터 안에서 정족수 노드의 확인 응답을 기다리기 때문에 데이터센터 간 연결의 지연과 중단에 영향 받지 않음.
    
- 동시 쓰기 감지
    - 다이나모 스타일은 여러 클라이언트가 동시에 같은 키에 쓰는 것을 허용하므로 엄격한 정족수 사용해도 충돌 발생
    - 충돌은 읽기 복구나 암시된 핸드오프 중에도 발생할 수 있음.
    - "이전 발생" 관계와 동시성
      - 이전 발생(happens-before)
        - 작업 B가 어떤 방식으로든 A를 기반으로 한다면 작업 A는 작업 B의 이전 발생임.
      - 한 작업이 다른 작업 이전에 발생했는지가 동시성의 의미를 정의하는 핵심
      - 동시성 정의에 정확한 시간은 중요하지 않음.
    - 각 작업이 서로 알지 못하면 단순히 두 작업은 동시에 수행됐다 말한다. 
    - 해결 방법
        - 최종 쓰기 승리(동시 쓰기 버리기)
            - LWW라고도 함. 
            - 제일 큰 타임스탬프를 선택하고 예전 타임스탬프를 가진 쓰기는 무시
            - 단점
                - 동시 쓰기가 아니라도 쓰기가 삭제될 수 있음
                - 캐싱과 같이 손실된 쓰기를 허용하는 상황 있음. 손실 데이터 허용하지 않는다면 LWW가 충돌 해소에 적합하지 않다.
            - 안전하게 사용하는 방법은 키를 한번만 쓰고 이후에는 불변 값으로 다루는 것
                - ex) 카산드라는 키로 UUID를 사용해 모든 쓰기 작업에 고유한 키를 부여
        - 이전 발생 관계 파악하기 & 동시에 쓴 값 병합
            - 이전 발생 관계 파악 알고리즘
                - 서버가 모든 키에 대한 버전 번호 유지하고 키 기록할 때마다 버전 번호 증가시킴
                - 클라이언트가 키 읽을 때, 서버는 최신버전 뿐 아니라 덮어쓰지 않은 모든 값 반환
                - 클라이언트가 키를 기록할 때는 이전 읽기의 버전 번호 포함해야 하고 이전 읽기에서 받은 모든 값을 함께 합쳐야 함.
                - 서버가 특정 버전 번호 가진 쓰기 받을 때 해당 버전 이하 모든 값을 덮어쓸 수 있음. 하지만 특정 번호 보다 높은 버전 번호의 모든 값은 유지 
            - 동시에 쓴 값 병합
                - 어떤 데이터도 자동으로 삭제 되지 않음 보장
                - 클라이언트가 추가적으로 작업 수행해야함.
                - 동시에 발생한 값을 리악에선 형제(sibling) 값이라 부름.
                - 다중 리더 복제에서 충돌을 해소하는 문제와 본질적으로 같음. 
                - 접근 방식
                    - 합집합 : 추가에 대해 문제없으나, 삭제시 올바른 결과 얻을 수 없음
                    - 삭제 방법: 시스템이 형제 병합시 상품 제거했음을 나타내기 위해 해당 버전 번호에 표시를 남겨야함(툼스톤)
        - 버전 벡터
            - 다중 복제본의 동시 쓰기 받아 들이기 위해 키당 버전 번호뿐 아니라 복제본당 버전 번호도 사용하는 것
            - 모든 복제본의 버전 번호 모음을 버전 벡터라고 함.
    
정리
- 복제의 용도
    - 고가용성
    - 연결이 끊긴 작업: 네트워크 중단에도 app이 계속 동작할 수 있게함
    - 지연 시간: 사용자 가까운 위치에 데이터 배치 
    - 확장성: 더 많은 읽기 작업 처리
    
- 소프트웨어 버그 때문에 드러나지 않는 데이터 오염과 같이 모르는 사이에 일어나는 결함까지는 고려하지 않더라도 최소한 사용할 수 없는 노드와 네트워크 중단에는 대처 필요
- 복제 접근 방식
    - 단일 리더 복제
        - 이해하기 쉽고 충돌 해소에 대한 우려 없음
    - 다중 리더 복제
        - 쓰기를 여러 노드 중 쓰기를 받아 들일 수 있는 노드로 전송
        - 결함 노드, 네트워크 중단, 지연시간 급증에 견고
        - 설명하기 어렵고 일관성이 거의 보장되지 않음. 
    - 리더 없는 복제 
        - 쓰기를 여러 노드로 전송
        - 읽기도 병렬로 여러 노드에서 읽어서 오래된 데이터 감지
        - 결함 노드, 네트워크 중단, 지연시간 급증에 견고
        - 설명하기 어렵고 일관성이 거의 보장되지 않음.
    
- 동기 방식
    - 결함이 있을 때 시스템 작동에 중요한 영향
    - 동기
    - 비동기
        - 시스템이 원활할 땐 빠르다
        - 복제 지연 증가하고 서버 장애 발생시 어떤 일이 일어났는지 파악 필요
        - 리더가 고장나고 갱신된 팔로워를 새로운 리더로 승격하면 최근에 커밋된 데이터를 잃을 수 있다.
    
- 복제 지연으로 인한 이상 현상에 대한 일관성 모델
    - 쓰기 후 일관성: 사용자는 자신이 제출한 데이터를 항상 볼 수 있어야 함
    - 단조 읽기: 사용자가 어떤 시점 데이터 본 이후, 예전 시점의 데이터는 볼 수 없다
    - 일관된 순서로 읽기: 인과성이 있는 상태의 데이터를 봐야한다. 
    
- 다중 리더 복제와 리더 없는 복제 동시성 문제
    - 쓰기 충돌 가능
    

        
    

    